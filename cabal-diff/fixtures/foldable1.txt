-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Class of non-empty data structures that can be folded to a summary value.
--   
--   Class of non-empty data structures that can be folded to a summary
--   value.
--   
--   A compatibility package for <tt>Foldable1</tt> class which will be in
--   base-4.??
@package foldable1
@version 0.2


-- | class of non-empty data structures that can be folded to a summary
--   value.
module Data.Foldable1

-- | Non-empty data structures that can be folded.
class Foldable t => Foldable1 t

-- | Combine the elements of a structure using a semigroup.
fold1 :: (Foldable1 t, Semigroup m) => t m -> m

-- | Map each element of the structure to a semigroup, and combine the
--   results.
--   
--   <pre>
--   &gt;&gt;&gt; foldMap1 Sum (1 :| [2, 3, 4])
--   Sum {getSum = 10}
--   </pre>
foldMap1 :: (Foldable1 t, Semigroup m) => (a -> m) -> t a -> m

-- | A variant of <a>foldMap1</a> that is strict in the accumulator.
--   
--   <pre>
--   &gt;&gt;&gt; foldMap1' Sum (1 :| [2, 3, 4])
--   Sum {getSum = 10}
--   </pre>
foldMap1' :: (Foldable1 t, Semigroup m) => (a -> m) -> t a -> m

-- | Right-associative fold of a structure.
--   
--   In the case of lists, <a>foldr1</a>, when applied to a binary
--   operator, and a list, reduces the list using the binary operator, from
--   right to left:
--   
--   <pre>
--   foldr1 f [x1, x2, ..., xn] == x1 `f` (x2 `f` ... (xn1 `f` xn )...)
--   </pre>
--   
--   Note that, since the head of the resulting expression is produced by
--   an application of the operator to the first element of the list,
--   <a>foldr1</a> can produce a terminating expression from an infinite
--   list.
--   
--   For a general <a>Foldable1</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldr1 f = foldr1 f . <a>toNonEmpty</a>
--   </pre>
foldr1 :: Foldable1 t => (a -> a -> a) -> t a -> a

-- | Right-associative fold of a structure, but with strict application of
--   the operator.
foldr1' :: Foldable1 t => (a -> a -> a) -> t a -> a

-- | Left-associative fold of a structure.
--   
--   In the case of lists, <a>foldl1</a>, when applied to a binary
--   operator, and a list, reduces the list using the binary operator, from
--   left to right:
--   
--   <pre>
--   foldl1 f [x1, x2, ..., xn] == (...((x1 `f` x2) `f`...) `f` xn
--   </pre>
--   
--   Note that to produce the outermost application of the operator the
--   entire input list must be traversed. This means that <a>foldl1</a>
--   will diverge if given an infinite list.
--   
--   Also note that if you want an efficient left-fold, you probably want
--   to use <a>foldl1'</a> instead of <a>foldl1</a>. The reason for this is
--   that latter does not force the "inner" results (e.g. <tt>x1 `f`
--   x2</tt> in the above example) before applying them to the operator
--   (e.g. to <tt>(`f` x3)</tt>). This results in a thunk chain
--   &lt;math&gt; elements long, which then must be evaluated from the
--   outside-in.
--   
--   For a general <a>Foldable1</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldl1 f z = foldl1 f . <a>toNonEmpty</a>
--   </pre>
foldl1 :: Foldable1 t => (a -> a -> a) -> t a -> a

-- | Left-associative fold of a structure but with strict application of
--   the operator.
--   
--   This ensures that each step of the fold is forced to weak head normal
--   form before being applied, avoiding the collection of thunks that
--   would otherwise occur. This is often what you want to strictly reduce
--   a finite list to a single, monolithic result (e.g. <tt>length</tt>).
--   
--   For a general <a>Foldable1</a> structure this should be semantically
--   identical to,
--   
--   <pre>
--   foldl1' f z = foldl1 f . <a>toNonEmpty</a>
--   </pre>
foldl1' :: Foldable1 t => (a -> a -> a) -> t a -> a

-- | List of elements of a structure, from left to right.
--   
--   <pre>
--   &gt;&gt;&gt; toNonEmpty (Identity 2)
--   2 :| []
--   </pre>
toNonEmpty :: Foldable1 t => t a -> NonEmpty a

-- | The largest element of a non-empty structure.
--   
--   <pre>
--   &gt;&gt;&gt; maximum1 (32 :| [64, 8, 128, 16])
--   128
--   </pre>
maximum1 :: forall a. (Foldable1 t, Ord a) => t a -> a

-- | The least element of a non-empty structure.
--   
--   <pre>
--   &gt;&gt;&gt; minimum1 (32 :| [64, 8, 128, 16])
--   8
--   </pre>
minimum1 :: forall a. (Foldable1 t, Ord a) => t a -> a

-- | The first element of a non-empty structure.
--   
--   <pre>
--   &gt;&gt;&gt; head1 (1 :| [2, 3, 4])
--   1
--   </pre>
head1 :: Foldable1 t => t a -> a

-- | The last element of a non-empty structure.
--   
--   <pre>
--   &gt;&gt;&gt; last1 (1 :| [2, 3, 4])
--   4
--   </pre>
last1 :: Foldable1 t => t a -> a

-- | For <tt>Functor</tt>s, <tt><a>foldr1Map</a> f g = foldr1 g .
--   <tt>fmap</tt> g</tt>.
foldr1Map :: Foldable1 t => (a -> b) -> (b -> b -> b) -> t a -> b

-- | For <tt>Functor</tt>s, <tt><a>foldl1'Map</a> f g = foldl1' g .
--   <tt>fmap</tt> g</tt>.
foldl1'Map :: Foldable1 t => (a -> b) -> (b -> b -> b) -> t a -> b

-- | For <tt>Functor</tt>s, <tt><a>foldl1Map</a> f g = foldl1 g .
--   <tt>fmap</tt> g</tt>.
foldl1Map :: Foldable1 t => (a -> b) -> (b -> b -> b) -> t a -> b

-- | For <tt>Functor</tt>s, <tt><a>foldr1'Map</a> f g = foldr1' g .
--   <tt>fmap</tt> g</tt>.
foldr1'Map :: Foldable1 t => (a -> b) -> (b -> b -> b) -> t a -> b

-- | Insert an <tt>m</tt> between each pair of <tt>t m</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; intercalate1 ", " $ "hello" :| ["how", "are", "you"]
--   "hello, how, are, you"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; intercalate1 ", " $ "hello" :| []
--   "hello"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; intercalate1 mempty $ "I" :| ["Am", "Fine", "You?"]
--   "IAmFineYou?"
--   </pre>
intercalate1 :: (Foldable1 t, Semigroup m) => m -> t m -> m

-- | Monadic fold over the elements of a non-empty structure, associating
--   to the right, i.e. from right to left.
foldrM1 :: (Foldable1 t, Monad m) => (a -> a -> m a) -> t a -> m a

-- | Monadic fold over the elements of a non-empty structure, associating
--   to the left, i.e. from left to right.
foldlM1 :: (Foldable1 t, Monad m) => (a -> a -> m a) -> t a -> m a

-- | The largest element of a non-empty structure with respect to the given
--   comparison function.
maximum1By :: Foldable1 t => (a -> a -> Ordering) -> t a -> a

-- | The least element of a non-empty structure with respect to the given
--   comparison function.
minimum1By :: Foldable1 t => (a -> a -> Ordering) -> t a -> a
instance Data.Foldable1.Foldable1 f => Data.Foldable1.Foldable1 (Data.Semigroup.Internal.Alt f)
instance Data.Foldable1.Foldable1 f => Data.Foldable1.Foldable1 (Data.Monoid.Ap f)
instance Data.Foldable1.Foldable1 f => Data.Foldable1.Foldable1 (GHC.Generics.Rec1 f)
instance Data.Foldable1.Foldable1 f => Data.Foldable1.Foldable1 (GHC.Generics.M1 i c f)
instance Data.Foldable1.Foldable1 f => Data.Foldable1.Foldable1 (Control.Monad.Trans.Identity.IdentityT f)
instance GHC.Base.Semigroup (Data.Foldable1.NonEmptyDList a)
instance Data.Foldable1.Foldable1 GHC.Base.NonEmpty
instance Data.Foldable1.Foldable1 ((,) a)
instance Data.Foldable1.Foldable1 Data.Semigroup.Internal.Dual
instance Data.Foldable1.Foldable1 Data.Semigroup.Internal.Sum
instance Data.Foldable1.Foldable1 Data.Semigroup.Internal.Product
instance Data.Foldable1.Foldable1 Data.Semigroup.Min
instance Data.Foldable1.Foldable1 Data.Semigroup.Max
instance Data.Foldable1.Foldable1 Data.Semigroup.First
instance Data.Foldable1.Foldable1 Data.Semigroup.Last
instance Data.Foldable1.Foldable1 Data.Ord.Down
instance Data.Foldable1.Foldable1 Data.Complex.Complex
instance Data.Foldable1.Foldable1 GHC.Generics.V1
instance Data.Foldable1.Foldable1 GHC.Generics.Par1
instance (Data.Foldable1.Foldable1 f, Data.Foldable1.Foldable1 g) => Data.Foldable1.Foldable1 (f GHC.Generics.:+: g)
instance (Data.Foldable1.Foldable1 f, Data.Foldable1.Foldable1 g) => Data.Foldable1.Foldable1 (f GHC.Generics.:*: g)
instance (Data.Foldable1.Foldable1 f, Data.Foldable1.Foldable1 g) => Data.Foldable1.Foldable1 (f GHC.Generics.:.: g)
instance Data.Foldable1.Foldable1 Data.Functor.Identity.Identity
instance (Data.Foldable1.Foldable1 f, Data.Foldable1.Foldable1 g) => Data.Foldable1.Foldable1 (Data.Functor.Product.Product f g)
instance (Data.Foldable1.Foldable1 f, Data.Foldable1.Foldable1 g) => Data.Foldable1.Foldable1 (Data.Functor.Sum.Sum f g)
instance (Data.Foldable1.Foldable1 f, Data.Foldable1.Foldable1 g) => Data.Foldable1.Foldable1 (Data.Functor.Compose.Compose f g)
instance Data.Foldable1.Foldable1 Data.Tree.Tree
instance Data.Foldable1.Foldable1 f => Data.Foldable1.Foldable1 (Data.Functor.Reverse.Reverse f)
instance Data.Foldable1.Foldable1 f => Data.Foldable1.Foldable1 (Control.Applicative.Backwards.Backwards f)
instance Data.Foldable1.Foldable1 f => Data.Foldable1.Foldable1 (Control.Applicative.Lift.Lift f)
instance Data.Foldable1.Foldable1 (Data.Tagged.Tagged b)
instance GHC.Base.Semigroup (Data.Foldable1.FromMaybe b)
