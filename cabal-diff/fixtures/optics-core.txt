-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Optics as an abstract interface: core definitions
--   
--   This package makes it possible to define and use Lenses, Traversals,
--   Prisms and other optics, using an abstract interface.
--   
--   This variant provides core definitions with a minimal dependency
--   footprint. See the <tt><a>optics</a></tt> package (and its
--   dependencies) for documentation and the "batteries-included" variant.
@package optics-core
@version 0.2


-- | Classes for co- and contravariant bifunctors.
--   
--   This module is intended for internal use only, and may change without
--   warning in subsequent releases.
module Optics.Internal.Bi

-- | Class for (covariant) bifunctors.
class Bifunctor p
bimap :: Bifunctor p => (a -> b) -> (c -> d) -> p i a c -> p i b d
first :: Bifunctor p => (a -> b) -> p i a c -> p i b c
second :: Bifunctor p => (c -> d) -> p i a c -> p i a d

-- | Class for contravariant bifunctors.
class Bicontravariant p
contrabimap :: Bicontravariant p => (b -> a) -> (d -> c) -> p i a c -> p i b d
contrafirst :: Bicontravariant p => (b -> a) -> p i a c -> p i b c
contrasecond :: Bicontravariant p => (c -> b) -> p i a b -> p i a c

-- | If <tt>p</tt> is a <a>Profunctor</a> and a <a>Bifunctor</a> then its
--   left parameter must be phantom.
lphantom :: (Profunctor p, Bifunctor p) => p i a c -> p i b c

-- | If <tt>p</tt> is a <a>Profunctor</a> and <a>Bicontravariant</a> then
--   its right parameter must be phantom.
rphantom :: (Profunctor p, Bicontravariant p) => p i c a -> p i c b
instance Optics.Internal.Bi.Bicontravariant (Data.Profunctor.Indexed.Forget r)
instance Optics.Internal.Bi.Bicontravariant (Data.Profunctor.Indexed.ForgetM r)
instance Optics.Internal.Bi.Bicontravariant (Data.Profunctor.Indexed.IxForget r)
instance Optics.Internal.Bi.Bicontravariant (Data.Profunctor.Indexed.IxForgetM r)
instance Optics.Internal.Bi.Bifunctor Data.Profunctor.Indexed.Tagged


-- | This module is intended for internal use only, and may change without
--   warning in subsequent releases.
module Optics.Internal.Optic.TypeLevel

-- | A list of index types, used for indexed optics.
type IxList = [Type]

-- | An alias for an empty index-list
type NoIx = ('[] :: IxList)

-- | Singleton index list
type WithIx i = ('[i] :: IxList)

-- | Show a type surrounded by quote marks.
type family QuoteType (x :: Type) :: ErrorMessage

-- | Curry a type-level list.
--   
--   In pseudo (dependent-)Haskell:
--   
--   <pre>
--   <a>Curry</a> xs y = <a>foldr</a> (-&gt;) y xs
--   </pre>
type family Curry (xs :: IxList) (y :: Type) :: Type

-- | Append two type-level lists together.
type family Append (xs :: IxList) (ys :: IxList) :: IxList

-- | Class that is inhabited by all type-level lists <tt>xs</tt>, providing
--   the ability to compose a function under <tt><a>Curry</a> xs</tt>.
class CurryCompose xs

-- | Compose a function under <tt><a>Curry</a> xs</tt>. This generalises
--   <tt>(<a>.</a>)</tt> (aka <a>fmap</a> for <tt>(-&gt;)</tt>) to work for
--   curried functions with one argument for each type in the list.
composeN :: CurryCompose xs => (i -> j) -> Curry xs i -> Curry xs j
instance Optics.Internal.Optic.TypeLevel.CurryCompose '[]
instance Optics.Internal.Optic.TypeLevel.CurryCompose xs => Optics.Internal.Optic.TypeLevel.CurryCompose (x : xs)


-- | This module is intended for internal use only, and may change without
--   warning in subsequent releases.
module Optics.Internal.Optic.Types

-- | Kind for types used as optic tags, such as <a>A_Lens</a>.
type OpticKind = Type

-- | Tag for an iso.
data An_Iso :: OpticKind

-- | Tag for a lens.
data A_Lens :: OpticKind

-- | Tag for a prism.
data A_Prism :: OpticKind

-- | Tag for an affine traversal.
data An_AffineTraversal :: OpticKind

-- | Tag for a traversal.
data A_Traversal :: OpticKind

-- | Tag for a setter.
data A_Setter :: OpticKind

-- | Tag for a reversed prism.
data A_ReversedPrism :: OpticKind

-- | Tag for a getter.
data A_Getter :: OpticKind

-- | Tag for an affine fold.
data An_AffineFold :: OpticKind

-- | Tag for a fold.
data A_Fold :: OpticKind

-- | Tag for a reversed lens.
data A_ReversedLens :: OpticKind

-- | Tag for a review.
data A_Review :: OpticKind

-- | Mapping tag types <tt>k</tt> to constraints on <tt>p</tt>.
--   
--   Using this type family we define the constraints that the various
--   flavours of optics have to fulfill.
type family Constraints (k :: OpticKind) (p :: Type -> Type -> Type -> Type) :: Constraint


-- | Instances to implement the subtyping hierarchy between optics.
--   
--   This module is intended for internal use only, and may change without
--   warning in subsequent releases.
module Optics.Internal.Optic.Subtyping

-- | Subtyping relationship between kinds of optics.
--   
--   An instance of <tt><a>Is</a> k l</tt> means that any <tt><a>Optic</a>
--   k</tt> can be used as an <tt><a>Optic</a> l</tt>. For example, we have
--   an <tt><a>Is</a> <a>A_Lens</a> <a>A_Traversal</a></tt> instance, but
--   not <tt><a>Is</a> <a>A_Traversal</a> <a>A_Lens</a></tt>.
--   
--   This class needs instances for all possible combinations of tags.
class Is k l

-- | Witness of the subtyping relationship.
implies :: Is k l => proxy k l p -> (Constraints k p => r) -> Constraints l p => r

-- | Computes the least upper bound of two optics kinds.
--   
--   <tt>Join k l</tt> represents the least upper bound of an <tt>Optic
--   k</tt> and an <tt>Optic l</tt>. This means in particular that
--   composition of an <tt>Optic k</tt> and an <tt>Optic k</tt> will yield
--   an <tt>Optic (Join k l)</tt>.
type family Join (k :: OpticKind) (l :: OpticKind)
instance (TypeError ...) => Optics.Internal.Optic.Subtyping.Is k l
instance Optics.Internal.Optic.Subtyping.Is k k
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.An_Iso Optics.Internal.Optic.Types.A_ReversedLens
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.An_Iso Optics.Internal.Optic.Types.A_ReversedPrism
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.An_Iso Optics.Internal.Optic.Types.A_Prism
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.An_Iso Optics.Internal.Optic.Types.A_Review
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.An_Iso Optics.Internal.Optic.Types.A_Lens
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.An_Iso Optics.Internal.Optic.Types.A_Getter
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.An_Iso Optics.Internal.Optic.Types.An_AffineTraversal
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.An_Iso Optics.Internal.Optic.Types.An_AffineFold
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.An_Iso Optics.Internal.Optic.Types.A_Traversal
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.An_Iso Optics.Internal.Optic.Types.A_Fold
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.An_Iso Optics.Internal.Optic.Types.A_Setter
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.A_ReversedLens Optics.Internal.Optic.Types.A_Review
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.A_ReversedPrism Optics.Internal.Optic.Types.A_Getter
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.A_ReversedPrism Optics.Internal.Optic.Types.An_AffineFold
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.A_ReversedPrism Optics.Internal.Optic.Types.A_Fold
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.A_Prism Optics.Internal.Optic.Types.A_Review
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.A_Prism Optics.Internal.Optic.Types.An_AffineTraversal
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.A_Prism Optics.Internal.Optic.Types.An_AffineFold
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.A_Prism Optics.Internal.Optic.Types.A_Traversal
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.A_Prism Optics.Internal.Optic.Types.A_Fold
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.A_Prism Optics.Internal.Optic.Types.A_Setter
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.A_Lens Optics.Internal.Optic.Types.A_Getter
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.A_Lens Optics.Internal.Optic.Types.An_AffineTraversal
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.A_Lens Optics.Internal.Optic.Types.An_AffineFold
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.A_Lens Optics.Internal.Optic.Types.A_Traversal
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.A_Lens Optics.Internal.Optic.Types.A_Fold
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.A_Lens Optics.Internal.Optic.Types.A_Setter
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.A_Getter Optics.Internal.Optic.Types.An_AffineFold
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.A_Getter Optics.Internal.Optic.Types.A_Fold
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.An_AffineTraversal Optics.Internal.Optic.Types.An_AffineFold
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.An_AffineTraversal Optics.Internal.Optic.Types.A_Traversal
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.An_AffineTraversal Optics.Internal.Optic.Types.A_Fold
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.An_AffineTraversal Optics.Internal.Optic.Types.A_Setter
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.An_AffineFold Optics.Internal.Optic.Types.A_Fold
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.A_Traversal Optics.Internal.Optic.Types.A_Fold
instance Optics.Internal.Optic.Subtyping.Is Optics.Internal.Optic.Types.A_Traversal Optics.Internal.Optic.Types.A_Setter


-- | Core optic types and subtyping machinery.
--   
--   This module contains the core <a>Optic</a> types, and the underlying
--   machinery that we need in order to implement the subtyping between
--   various different flavours of optics.
--   
--   The composition operator for optics is also defined here.
--   
--   This module is intended for internal use only, and may change without
--   warning in subsequent releases.
module Optics.Internal.Optic

-- | Wrapper newtype for the whole family of optics.
--   
--   The first parameter <tt>k</tt> identifies the particular optic kind
--   (e.g. <a>A_Lens</a> or <a>A_Traversal</a>).
--   
--   The parameter <tt>is</tt> is a list of types available as indices.
--   This will typically be <a>NoIx</a> for unindexed optics, or
--   <a>WithIx</a> for optics with a single index. See the "Indexed optics"
--   section of the overview documentation in the <tt>Optics</tt> module of
--   the main <tt>optics</tt> package for more details.
--   
--   The parameters <tt>s</tt> and <tt>t</tt> represent the "big"
--   structure, whereas <tt>a</tt> and <tt>b</tt> represent the "small"
--   structure.
newtype Optic (k :: OpticKind) (is :: IxList) s t a b
Optic :: (forall p i. Profunctor p => Optic_ k p i (Curry is i) s t a b) -> Optic s t a b
[getOptic] :: Optic s t a b -> forall p i. Profunctor p => Optic_ k p i (Curry is i) s t a b

-- | Common special case of <a>Optic</a> where source and target types are
--   equal.
--   
--   Here, we need only one "big" and one "small" type. For lenses, this
--   means that in the restricted form we cannot do type-changing updates.
type Optic' k is s a = Optic k is s s a a

-- | Type representing the various kinds of optics.
--   
--   The tag parameter <tt>k</tt> is translated into constraints on
--   <tt>p</tt> via the type family <a>Constraints</a>.
type Optic_ k p i j s t a b = Constraints k p => Optic__ p i j s t a b

-- | Optic internally as a profunctor transformation.
type Optic__ p i j s t a b = p i a b -> p j s t

-- | Explicit cast from one optic flavour to another.
--   
--   The resulting optic kind is given in the first type argument, so you
--   can use TypeApplications to set it. For example
--   
--   <pre>
--   <a>castOptic</a> @<a>A_Lens</a> o
--   </pre>
--   
--   turns <tt>o</tt> into a <a>Lens</a>.
--   
--   This is the identity function, modulo some constraint jiggery-pokery.
castOptic :: forall destKind srcKind is s t a b. Is srcKind destKind => Optic srcKind is s t a b -> Optic destKind is s t a b

-- | Compose two optics of compatible flavours.
--   
--   Returns an optic of the appropriate supertype. If either or both
--   optics are indexed, the composition preserves all the indices.
(%) :: (Is k m, Is l m, m ~ Join k l, ks ~ Append is js) => Optic k is s t u v -> Optic l js u v a b -> Optic m ks s t a b
infixl 9 %

-- | Compose two optics of the same flavour.
--   
--   Normally you can simply use (<a>%</a>) instead, but this may be useful
--   to help type inference if the type of one of the optics is otherwise
--   under-constrained.
(%%) :: forall k is js ks s t u v a b. ks ~ Append is js => Optic k is s t u v -> Optic k js u v a b -> Optic k ks s t a b
infixl 9 %%

-- | Flipped function application, specialised to optics and binding
--   tightly.
--   
--   Useful for post-composing optics transformations:
--   
--   <pre>
--   &gt;&gt;&gt; toListOf (ifolded %&amp; ifiltered (\i s -&gt; length s &lt;= i)) ["", "a","abc"]
--   ["","a"]
--   </pre>
(%&) :: Optic k is s t a b -> (Optic k is s t a b -> Optic l js s' t' a' b') -> Optic l js s' t' a' b'
infixl 9 %&

-- | Proxy type for use as an argument to <a>implies</a>.
data IsProxy (k :: Type) (l :: Type) (p :: Type -> Type -> Type -> Type)
IsProxy :: IsProxy

-- | Support for overloaded labels as optics. An overloaded label
--   <tt>#foo</tt> can be used as an optic if there is an instance of
--   <tt><a>LabelOptic</a> "foo" k s t a b</tt>.
--   
--   See <a>Optics.Label</a> for examples and further details.
class LabelOptic (name :: Symbol) k s t a b | name s -> k a, name t -> k b, name s b -> t, name t a -> s

-- | Used to interpret overloaded label syntax. An overloaded label
--   <tt>#foo</tt> corresponds to <tt><a>labelOptic</a> @"foo"</tt>.
labelOptic :: LabelOptic name k s t a b => Optic k NoIx s t a b

-- | Type synonym for a type-preserving optic as overloaded label.
type LabelOptic' name k s a = LabelOptic name k s s a a
instance (Optics.Internal.Optic.LabelOptic name k s t a b, (TypeError ...)) => Optics.Internal.Optic.LabelOptic name k s t a b
instance (Optics.Internal.Optic.LabelOptic name k s t a b, is Data.Type.Equality.~ Optics.Internal.Optic.TypeLevel.NoIx) => GHC.OverloadedLabels.IsLabel name (Optics.Internal.Optic.Optic k is s t a b)
instance (ys Data.Type.Equality.~ zs) => Optics.Internal.Optic.AppendProof '[] ys zs
instance (Optics.Internal.Optic.TypeLevel.Append (x : xs) ys Data.Type.Equality.~ (x : zs), Optics.Internal.Optic.AppendProof xs ys zs) => Optics.Internal.Optic.AppendProof (x : xs) ys (x : zs)


-- | Internal implementation details of folds.
--   
--   This module is intended for internal use only, and may change without
--   warning in subsequent releases.
module Optics.Internal.Fold

-- | Internal implementation of <a>foldVL</a>.
foldVL__ :: (Bicontravariant p, Traversing p) => (forall f. Applicative f => (a -> f u) -> s -> f v) -> Optic__ p i i s t a b

-- | Internal implementation of <a>folded</a>.
folded__ :: (Bicontravariant p, Traversing p, Foldable f) => Optic__ p i i (f a) (f b) a b

-- | Internal implementation of <a>foldring</a>.
foldring__ :: (Bicontravariant p, Traversing p) => (forall f. Applicative f => (a -> f u -> f u) -> f v -> s -> f w) -> Optic__ p i i s t a b

-- | Used for <a>headOf</a> and <a>iheadOf</a>.
data Leftmost a
LPure :: Leftmost a
LLeaf :: a -> Leftmost a
LStep :: Leftmost a -> Leftmost a

-- | Extract the <a>Leftmost</a> element. This will fairly eagerly
--   determine that it can return <a>Just</a> the moment it sees any
--   element at all.
getLeftmost :: Leftmost a -> Maybe a

-- | Used for <a>lastOf</a> and <a>ilastOf</a>.
data Rightmost a
RPure :: Rightmost a
RLeaf :: a -> Rightmost a
RStep :: Rightmost a -> Rightmost a

-- | Extract the <a>Rightmost</a> element. This will fairly eagerly
--   determine that it can return <a>Just</a> the moment it sees any
--   element at all.
getRightmost :: Rightmost a -> Maybe a
instance GHC.Base.Semigroup (Optics.Internal.Fold.Rightmost a)
instance GHC.Base.Monoid (Optics.Internal.Fold.Rightmost a)
instance GHC.Base.Semigroup (Optics.Internal.Fold.Leftmost a)
instance GHC.Base.Monoid (Optics.Internal.Fold.Leftmost a)


-- | A <a>Getter</a> is simply a function considered as an <a>Optic</a>.
--   
--   Given a function <tt>f :: S -&gt; A</tt>, we can convert it into a
--   <tt><a>Getter</a> S A</tt> using <a>to</a>, and convert back to a
--   function using <a>view</a>.
--   
--   This is typically useful not when you have functions/<a>Getter</a>s
--   alone, but when you are composing multiple <a>Optic</a>s to produce a
--   <a>Getter</a>.
module Optics.Getter

-- | Type synonym for a getter.
type Getter s a = Optic' A_Getter NoIx s a

-- | Build a getter from a function.
to :: (s -> a) -> Getter s a

-- | View the value pointed to by a getter.
--   
--   If you want to <a>view</a> a type-modifying optic that is
--   insufficiently polymorphic to be type-preserving, use <a>getting</a>.
view :: Is k A_Getter => Optic' k is s a -> s -> a

-- | View the function of the value pointed to by a getter.
views :: Is k A_Getter => Optic' k is s a -> (a -> r) -> s -> r

-- | Tag for a getter.
data A_Getter :: OpticKind


-- | This module defines operations to <a>coerce</a> the type parameters of
--   optics to a representationally equal type. For example, if we have
--   
--   <pre>
--   newtype MkInt = MkInt Int
--   </pre>
--   
--   and
--   
--   <pre>
--   l :: Lens' S Int
--   </pre>
--   
--   then
--   
--   <pre>
--   coerceA @Int @MkInt l :: Lens' S MkInt
--   </pre>
module Optics.Coerce

-- | Lift <a>coerce</a> to the <tt>s</tt> parameter of an optic.
coerceS :: Coercible s s' => Optic k is s t a b -> Optic k is s' t a b

-- | Lift <a>coerce</a> to the <tt>t</tt> parameter of an optic.
coerceT :: Coercible t t' => Optic k is s t a b -> Optic k is s t' a b

-- | Lift <a>coerce</a> to the <tt>a</tt> parameter of an optic.
coerceA :: Coercible a a' => Optic k is s t a b -> Optic k is s t a' b

-- | Lift <a>coerce</a> to the <tt>b</tt> parameter of an optic.
coerceB :: Coercible b b' => Optic k is s t a b -> Optic k is s t a b'


-- | An <a>AffineTraversal</a> is a <a>Traversal</a> that applies to at
--   most one element.
--   
--   These arise most frequently as the composition of a <a>Lens</a> with a
--   <a>Prism</a>.
module Optics.AffineTraversal

-- | Type synonym for a type-modifying affine traversal.
type AffineTraversal s t a b = Optic An_AffineTraversal NoIx s t a b

-- | Type synonym for a type-preserving affine traversal.
type AffineTraversal' s a = Optic' An_AffineTraversal NoIx s a

-- | Build an affine traversal from a matcher and an updater.
--   
--   If you want to build an <a>AffineTraversal</a> from the van Laarhoven
--   representation, use <a>atraversalVL</a>.
atraversal :: (s -> Either t a) -> (s -> b -> t) -> AffineTraversal s t a b

-- | Retrieve the value targeted by an <a>AffineTraversal</a> or return the
--   original value while allowing the type to change if it does not match.
--   
--   <pre>
--   <a>preview</a> o ≡ <a>either</a> (<a>const</a> <a>Nothing</a>) <a>id</a> . <a>matching</a> o
--   </pre>
matching :: Is k An_AffineTraversal => Optic k is s t a b -> s -> Either t a

-- | Filter result(s) of a traversal that don't satisfy a predicate.
--   
--   <i>Note:</i> This is <i>not</i> a legal <a>Traversal</a>, unless you
--   are very careful not to invalidate the predicate on the target.
--   
--   As a counter example, consider that given <tt>evens =
--   <a>unsafeFiltered</a> <a>even</a></tt> the second <a>Traversal</a> law
--   is violated:
--   
--   <pre>
--   <a>over</a> evens <a>succ</a> <a>.</a> <a>over</a> evens <a>succ</a> <a>/=</a> <a>over</a> evens (<a>succ</a> <a>.</a> <a>succ</a>)
--   </pre>
--   
--   So, in order for this to qualify as a legal <a>Traversal</a> you can
--   only use it for actions that preserve the result of the predicate!
--   
--   For a safe variant see <a>indices</a> (or <a>filtered</a> for
--   read-only optics).
unsafeFiltered :: (a -> Bool) -> AffineTraversal' a a

-- | Work with an affine traversal as a matcher and an updater.
withAffineTraversal :: Is k An_AffineTraversal => Optic k is s t a b -> ((s -> Either t a) -> (s -> b -> t) -> r) -> r

-- | Tag for an affine traversal.
data An_AffineTraversal :: OpticKind

-- | Type synonym for a type-modifying van Laarhoven affine traversal.
--   
--   Note: this isn't exactly van Laarhoven representation as there is no
--   <tt>Pointed</tt> class (which would be a superclass of
--   <a>Applicative</a> that contains <a>pure</a> but not
--   <a>&lt;*&gt;</a>). You can interpret the first argument as a
--   dictionary of <tt>Pointed</tt> that supplies the <tt>point</tt>
--   function (i.e. the implementation of <a>pure</a>).
--   
--   A <a>TraversalVL</a> has <a>Applicative</a> available and hence can
--   combine the effects arising from multiple elements using
--   <a>&lt;*&gt;</a>. In contrast, an <a>AffineTraversalVL</a> has no way
--   to combine effects from multiple elements, so it must act on at most
--   one element. (It can act on none at all thanks to the availability of
--   <tt>point</tt>.)
type AffineTraversalVL s t a b = forall f. Functor f => (forall r. r -> f r) -> (a -> f b) -> s -> f t

-- | Type synonym for a type-preserving van Laarhoven affine traversal.
type AffineTraversalVL' s a = AffineTraversalVL s s a a

-- | Build an affine traversal from the van Laarhoven representation.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   azSnd = atraversalVL $ \point f ab@(a, b) -&gt;
--     if a &gt;= 'a' &amp;&amp; a &lt;= 'z'
--     then (a, ) &lt;$&gt; f b
--     else point ab
--   :}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; preview azSnd ('a', "Hi")
--   Just "Hi"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; preview azSnd ('@', "Hi")
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over azSnd (++ "!!!") ('f', "Hi")
--   ('f',"Hi!!!")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; set azSnd "Bye" ('Y', "Hi")
--   ('Y',"Hi")
--   </pre>
atraversalVL :: AffineTraversalVL s t a b -> AffineTraversal s t a b

-- | Convert an affine traversal to its van Laarhoven representation.
toAtraversalVL :: Is k An_AffineTraversal => Optic k is s t a b -> AffineTraversalVL s t a b


module Data.Typeable.Optics

-- | An <a>AffineTraversal'</a> for working with a <a>cast</a> of a
--   <a>Typeable</a> value.
_cast :: (Typeable s, Typeable a) => AffineTraversal' s a

-- | An <a>AffineTraversal'</a> for working with a <a>gcast</a> of a
--   <a>Typeable</a> value.
_gcast :: (Typeable s, Typeable a) => AffineTraversal' (c s) (c a)


-- | An <a>AffineFold</a> is a <a>Fold</a> that contains at most one
--   element, or a <a>Getter</a> where the function may be partial.
module Optics.AffineFold

-- | Type synonym for an affine fold.
type AffineFold s a = Optic' An_AffineFold NoIx s a

-- | Create an <a>AffineFold</a> from a partial function.
--   
--   <pre>
--   &gt;&gt;&gt; preview (afolding listToMaybe) "foo"
--   Just 'f'
--   </pre>
afolding :: (s -> Maybe a) -> AffineFold s a

-- | Retrieve the value targeted by an <a>AffineFold</a>.
--   
--   <pre>
--   &gt;&gt;&gt; let _Right = prism Right $ either (Left . Left) Right
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; preview _Right (Right 'x')
--   Just 'x'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; preview _Right (Left 'y')
--   Nothing
--   </pre>
preview :: Is k An_AffineFold => Optic' k is s a -> s -> Maybe a

-- | Retrieve a function of the value targeted by an <a>AffineFold</a>.
previews :: Is k An_AffineFold => Optic' k is s a -> (a -> r) -> s -> Maybe r

-- | Filter result(s) of a fold that don't satisfy a predicate.
filtered :: (a -> Bool) -> AffineFold a a

-- | Check to see if this <a>AffineFold</a> doesn't match.
--   
--   <pre>
--   &gt;&gt;&gt; isn't _Just Nothing
--   True
--   </pre>
isn't :: Is k An_AffineFold => Optic' k is s a -> s -> Bool

-- | Try the first <a>AffineFold</a>. If it returns no entry, try the
--   second one.
--   
--   <pre>
--   &gt;&gt;&gt; preview (ix 1 % re _Left `afailing` ix 2 % re _Right) [0,1,2,3]
--   Just (Left 1)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; preview (ix 42 % re _Left `afailing` ix 2 % re _Right) [0,1,2,3]
--   Just (Right 2)
--   </pre>
--   
--   <i>Note:</i> There is no <a>summing</a> equivalent, because
--   <tt>asumming = afailing</tt>.
afailing :: (Is k An_AffineFold, Is l An_AffineFold) => Optic' k is s a -> Optic' l js s a -> AffineFold s a
infixl 3 `afailing`

-- | Tag for an affine fold.
data An_AffineFold :: OpticKind


-- | Internal implementation details of setters.
--   
--   This module is intended for internal use only, and may change without
--   warning in subsequent releases.
module Optics.Internal.Setter

-- | Internal implementation of <a>mapped</a>.
mapped__ :: (Mapping p, Functor f) => Optic__ p i i (f a) (f b) a b


-- | Internal implementation details of traversals.
--   
--   This module is intended for internal use only, and may change without
--   warning in subsequent releases.
module Optics.Internal.Traversal

-- | Internal implementation of <a>traversed</a>.
traversed__ :: (Traversing p, Traversable f) => Optic__ p i i (f a) (f b) a b


-- | This module is intended for internal use only, and may change without
--   warning in subsequent releases.
module Optics.Internal.Utils
data Identity' a
Identity' :: {-# UNPACK #-} !() -> a -> Identity' a

-- | Mark a value for evaluation to whnf.
--   
--   This allows us to, when applying a setter to a structure, evaluate
--   only the parts that we modify. If an optic focuses on multiple
--   targets, Applicative instance of Identity' makes sure that we force
--   evaluation of all of them, but we leave anything else alone.
wrapIdentity' :: a -> Identity' a
unwrapIdentity' :: Identity' a -> a

-- | Helper for <a>traverseOf_</a> and the like for better efficiency than
--   the foldr-based version.
--   
--   Note that the argument <tt>a</tt> of the result should not be used.
newtype Traversed f a
Traversed :: f a -> Traversed f a
runTraversed :: Functor f => Traversed f a -> f ()

-- | Helper for <a>failing</a> family to visit the first fold only once.
data OrT f a
OrT :: !Bool -> f a -> OrT f a

-- | Wrap the applicative action in <a>OrT</a> so that we know later that
--   it was executed.
wrapOrT :: f a -> OrT f a
(#.) :: Coercible b c => (b -> c) -> (a -> b) -> a -> c
(.#) :: Coercible a b => (b -> c) -> (a -> b) -> a -> c
instance GHC.Base.Functor f => GHC.Base.Functor (Optics.Internal.Utils.OrT f)
instance GHC.Base.Functor Optics.Internal.Utils.Identity'
instance GHC.Base.Applicative f => GHC.Base.Applicative (Optics.Internal.Utils.OrT f)
instance GHC.Base.Applicative f => GHC.Base.Semigroup (Optics.Internal.Utils.Traversed f a)
instance GHC.Base.Applicative f => GHC.Base.Monoid (Optics.Internal.Utils.Traversed f a)
instance GHC.Base.Applicative Optics.Internal.Utils.Identity'
instance Data.Profunctor.Indexed.Mapping (Data.Profunctor.Indexed.Star Optics.Internal.Utils.Identity')
instance Data.Profunctor.Indexed.Mapping (Data.Profunctor.Indexed.IxStar Optics.Internal.Utils.Identity')


-- | Internal implementation details of indexed optics.
--   
--   This module is intended for internal use only, and may change without
--   warning in subsequent releases.
module Optics.Internal.Indexed

-- | Show useful error message when a function expects optics without
--   indices.
class is ~ NoIx => AcceptsEmptyIndices (f :: Symbol) (is :: IxList)

-- | Check whether a list of indices is not empty and generate sensible
--   error message if it's not.
class NonEmptyIndices (is :: IxList)

-- | Generate sensible error messages in case a user tries to pass either
--   an unindexed optic or indexed optic with unflattened indices where
--   indexed optic with a single index is expected.
class is ~ '[i] => HasSingleIndex (is :: IxList) (i :: Type)
type family ShowTypes (types :: [Type]) :: ErrorMessage
data IntT f a
IntT :: {-# UNPACK #-} !Int -> f a -> IntT f a
unIntT :: IntT f a -> f a
newtype Indexing f a
Indexing :: (Int -> IntT f a) -> Indexing f a
[runIndexing] :: Indexing f a -> Int -> IntT f a

-- | Index a traversal by position of visited elements.
indexing :: ((a -> Indexing f b) -> s -> Indexing f t) -> (Int -> a -> f b) -> s -> f t

-- | Construct a conjoined indexed optic that provides a separate code path
--   when used without indices. Useful for defining indexed optics that are
--   as efficient as their unindexed equivalents when used without indices.
--   
--   <i>Note:</i> <tt><a>conjoined</a> f g</tt> is well-defined if and only
--   if <tt>f ≡ <a>noIx</a> g</tt>.
conjoined :: is `HasSingleIndex` i => Optic k NoIx s t a b -> Optic k is s t a b -> Optic k is s t a b

-- | Class for <a>Functor</a>s that have an additional read-only index
--   available.
class Functor f => FunctorWithIndex i f | f -> i
imap :: FunctorWithIndex i f => (i -> a -> b) -> f a -> f b
imap :: (FunctorWithIndex i f, TraversableWithIndex i f) => (i -> a -> b) -> f a -> f b

-- | Class for <a>Foldable</a>s that have an additional read-only index
--   available.
class (FunctorWithIndex i f, Foldable f) => FoldableWithIndex i f | f -> i
ifoldMap :: (FoldableWithIndex i f, Monoid m) => (i -> a -> m) -> f a -> m
ifoldMap :: (FoldableWithIndex i f, TraversableWithIndex i f, Monoid m) => (i -> a -> m) -> f a -> m
ifoldr :: FoldableWithIndex i f => (i -> a -> b -> b) -> b -> f a -> b
ifoldl' :: FoldableWithIndex i f => (i -> b -> a -> b) -> b -> f a -> b

-- | Traverse <a>FoldableWithIndex</a> ignoring the results.
itraverse_ :: (FoldableWithIndex i t, Applicative f) => (i -> a -> f b) -> t a -> f ()

-- | Flipped <a>itraverse_</a>.
ifor_ :: (FoldableWithIndex i t, Applicative f) => t a -> (i -> a -> f b) -> f ()

-- | Class for <a>Traversable</a>s that have an additional read-only index
--   available.
class (FoldableWithIndex i t, Traversable t) => TraversableWithIndex i t | t -> i
itraverse :: (TraversableWithIndex i t, Applicative f) => (i -> a -> f b) -> t a -> f (t b)

-- | Flipped <a>itraverse</a>
ifor :: (TraversableWithIndex i t, Applicative f) => t a -> (i -> a -> f b) -> f (t b)
instance Optics.Internal.Indexed.FunctorWithIndex () Data.Functor.Identity.Identity
instance Optics.Internal.Indexed.FoldableWithIndex () Data.Functor.Identity.Identity
instance Optics.Internal.Indexed.TraversableWithIndex () Data.Functor.Identity.Identity
instance Optics.Internal.Indexed.FunctorWithIndex k ((,) k)
instance Optics.Internal.Indexed.FoldableWithIndex k ((,) k)
instance Optics.Internal.Indexed.TraversableWithIndex k ((,) k)
instance Optics.Internal.Indexed.FunctorWithIndex r ((->) r)
instance Optics.Internal.Indexed.FunctorWithIndex GHC.Types.Int []
instance Optics.Internal.Indexed.FoldableWithIndex GHC.Types.Int []
instance Optics.Internal.Indexed.TraversableWithIndex GHC.Types.Int []
instance Optics.Internal.Indexed.FunctorWithIndex GHC.Types.Int Control.Applicative.ZipList
instance Optics.Internal.Indexed.FoldableWithIndex GHC.Types.Int Control.Applicative.ZipList
instance Optics.Internal.Indexed.TraversableWithIndex GHC.Types.Int Control.Applicative.ZipList
instance Optics.Internal.Indexed.FunctorWithIndex GHC.Types.Int GHC.Base.NonEmpty
instance Optics.Internal.Indexed.FoldableWithIndex GHC.Types.Int GHC.Base.NonEmpty
instance Optics.Internal.Indexed.TraversableWithIndex GHC.Types.Int GHC.Base.NonEmpty
instance Optics.Internal.Indexed.FunctorWithIndex () GHC.Maybe.Maybe
instance Optics.Internal.Indexed.FoldableWithIndex () GHC.Maybe.Maybe
instance Optics.Internal.Indexed.TraversableWithIndex () GHC.Maybe.Maybe
instance Optics.Internal.Indexed.FunctorWithIndex GHC.Types.Int Data.Sequence.Internal.Seq
instance Optics.Internal.Indexed.FoldableWithIndex GHC.Types.Int Data.Sequence.Internal.Seq
instance Optics.Internal.Indexed.TraversableWithIndex GHC.Types.Int Data.Sequence.Internal.Seq
instance Optics.Internal.Indexed.FunctorWithIndex GHC.Types.Int Data.IntMap.Internal.IntMap
instance Optics.Internal.Indexed.FoldableWithIndex GHC.Types.Int Data.IntMap.Internal.IntMap
instance Optics.Internal.Indexed.TraversableWithIndex GHC.Types.Int Data.IntMap.Internal.IntMap
instance Optics.Internal.Indexed.FunctorWithIndex k (Data.Map.Internal.Map k)
instance Optics.Internal.Indexed.FoldableWithIndex k (Data.Map.Internal.Map k)
instance Optics.Internal.Indexed.TraversableWithIndex k (Data.Map.Internal.Map k)
instance GHC.Arr.Ix i => Optics.Internal.Indexed.FunctorWithIndex i (GHC.Arr.Array i)
instance GHC.Arr.Ix i => Optics.Internal.Indexed.FoldableWithIndex i (GHC.Arr.Array i)
instance GHC.Arr.Ix i => Optics.Internal.Indexed.TraversableWithIndex i (GHC.Arr.Array i)
instance (Optics.Internal.Indexed.FunctorWithIndex i f, Optics.Internal.Indexed.FunctorWithIndex j g) => Optics.Internal.Indexed.FunctorWithIndex (i, j) (Data.Functor.Compose.Compose f g)
instance (Optics.Internal.Indexed.FoldableWithIndex i f, Optics.Internal.Indexed.FoldableWithIndex j g) => Optics.Internal.Indexed.FoldableWithIndex (i, j) (Data.Functor.Compose.Compose f g)
instance (Optics.Internal.Indexed.TraversableWithIndex i f, Optics.Internal.Indexed.TraversableWithIndex j g) => Optics.Internal.Indexed.TraversableWithIndex (i, j) (Data.Functor.Compose.Compose f g)
instance (Optics.Internal.Indexed.FunctorWithIndex i f, Optics.Internal.Indexed.FunctorWithIndex j g) => Optics.Internal.Indexed.FunctorWithIndex (Data.Either.Either i j) (Data.Functor.Sum.Sum f g)
instance (Optics.Internal.Indexed.FoldableWithIndex i f, Optics.Internal.Indexed.FoldableWithIndex j g) => Optics.Internal.Indexed.FoldableWithIndex (Data.Either.Either i j) (Data.Functor.Sum.Sum f g)
instance (Optics.Internal.Indexed.TraversableWithIndex i f, Optics.Internal.Indexed.TraversableWithIndex j g) => Optics.Internal.Indexed.TraversableWithIndex (Data.Either.Either i j) (Data.Functor.Sum.Sum f g)
instance (Optics.Internal.Indexed.FunctorWithIndex i f, Optics.Internal.Indexed.FunctorWithIndex j g) => Optics.Internal.Indexed.FunctorWithIndex (Data.Either.Either i j) (Data.Functor.Product.Product f g)
instance (Optics.Internal.Indexed.FoldableWithIndex i f, Optics.Internal.Indexed.FoldableWithIndex j g) => Optics.Internal.Indexed.FoldableWithIndex (Data.Either.Either i j) (Data.Functor.Product.Product f g)
instance (Optics.Internal.Indexed.TraversableWithIndex i f, Optics.Internal.Indexed.TraversableWithIndex j g) => Optics.Internal.Indexed.TraversableWithIndex (Data.Either.Either i j) (Data.Functor.Product.Product f g)
instance Optics.Internal.Indexed.FunctorWithIndex [GHC.Types.Int] Data.Tree.Tree
instance Optics.Internal.Indexed.FoldableWithIndex [GHC.Types.Int] Data.Tree.Tree
instance Optics.Internal.Indexed.TraversableWithIndex [GHC.Types.Int] Data.Tree.Tree
instance Optics.Internal.Indexed.FunctorWithIndex Data.Void.Void Data.Proxy.Proxy
instance Optics.Internal.Indexed.FoldableWithIndex Data.Void.Void Data.Proxy.Proxy
instance Optics.Internal.Indexed.TraversableWithIndex Data.Void.Void Data.Proxy.Proxy
instance Optics.Internal.Indexed.FunctorWithIndex i f => Optics.Internal.Indexed.FunctorWithIndex i (Control.Applicative.Backwards.Backwards f)
instance Optics.Internal.Indexed.FoldableWithIndex i f => Optics.Internal.Indexed.FoldableWithIndex i (Control.Applicative.Backwards.Backwards f)
instance Optics.Internal.Indexed.TraversableWithIndex i f => Optics.Internal.Indexed.TraversableWithIndex i (Control.Applicative.Backwards.Backwards f)
instance Optics.Internal.Indexed.FunctorWithIndex i f => Optics.Internal.Indexed.FunctorWithIndex i (Data.Functor.Reverse.Reverse f)
instance Optics.Internal.Indexed.FoldableWithIndex i f => Optics.Internal.Indexed.FoldableWithIndex i (Data.Functor.Reverse.Reverse f)
instance Optics.Internal.Indexed.TraversableWithIndex i f => Optics.Internal.Indexed.TraversableWithIndex i (Data.Functor.Reverse.Reverse f)
instance Optics.Internal.Indexed.FunctorWithIndex i m => Optics.Internal.Indexed.FunctorWithIndex i (Control.Monad.Trans.Identity.IdentityT m)
instance Optics.Internal.Indexed.FoldableWithIndex i m => Optics.Internal.Indexed.FoldableWithIndex i (Control.Monad.Trans.Identity.IdentityT m)
instance Optics.Internal.Indexed.TraversableWithIndex i m => Optics.Internal.Indexed.TraversableWithIndex i (Control.Monad.Trans.Identity.IdentityT m)
instance Optics.Internal.Indexed.FunctorWithIndex i m => Optics.Internal.Indexed.FunctorWithIndex (e, i) (Control.Monad.Trans.Reader.ReaderT e m)
instance Optics.Internal.Indexed.FunctorWithIndex Data.Void.Void GHC.Generics.V1
instance Optics.Internal.Indexed.FoldableWithIndex Data.Void.Void GHC.Generics.V1
instance Optics.Internal.Indexed.TraversableWithIndex Data.Void.Void GHC.Generics.V1
instance Optics.Internal.Indexed.FunctorWithIndex Data.Void.Void GHC.Generics.U1
instance Optics.Internal.Indexed.FoldableWithIndex Data.Void.Void GHC.Generics.U1
instance Optics.Internal.Indexed.TraversableWithIndex Data.Void.Void GHC.Generics.U1
instance Optics.Internal.Indexed.FunctorWithIndex () GHC.Generics.Par1
instance Optics.Internal.Indexed.FoldableWithIndex () GHC.Generics.Par1
instance Optics.Internal.Indexed.TraversableWithIndex () GHC.Generics.Par1
instance (Optics.Internal.Indexed.FunctorWithIndex i f, Optics.Internal.Indexed.FunctorWithIndex j g) => Optics.Internal.Indexed.FunctorWithIndex (i, j) (f GHC.Generics.:.: g)
instance (Optics.Internal.Indexed.FoldableWithIndex i f, Optics.Internal.Indexed.FoldableWithIndex j g) => Optics.Internal.Indexed.FoldableWithIndex (i, j) (f GHC.Generics.:.: g)
instance (Optics.Internal.Indexed.TraversableWithIndex i f, Optics.Internal.Indexed.TraversableWithIndex j g) => Optics.Internal.Indexed.TraversableWithIndex (i, j) (f GHC.Generics.:.: g)
instance (Optics.Internal.Indexed.FunctorWithIndex i f, Optics.Internal.Indexed.FunctorWithIndex j g) => Optics.Internal.Indexed.FunctorWithIndex (Data.Either.Either i j) (f GHC.Generics.:*: g)
instance (Optics.Internal.Indexed.FoldableWithIndex i f, Optics.Internal.Indexed.FoldableWithIndex j g) => Optics.Internal.Indexed.FoldableWithIndex (Data.Either.Either i j) (f GHC.Generics.:*: g)
instance (Optics.Internal.Indexed.TraversableWithIndex i f, Optics.Internal.Indexed.TraversableWithIndex j g) => Optics.Internal.Indexed.TraversableWithIndex (Data.Either.Either i j) (f GHC.Generics.:*: g)
instance (Optics.Internal.Indexed.FunctorWithIndex i f, Optics.Internal.Indexed.FunctorWithIndex j g) => Optics.Internal.Indexed.FunctorWithIndex (Data.Either.Either i j) (f GHC.Generics.:+: g)
instance (Optics.Internal.Indexed.FoldableWithIndex i f, Optics.Internal.Indexed.FoldableWithIndex j g) => Optics.Internal.Indexed.FoldableWithIndex (Data.Either.Either i j) (f GHC.Generics.:+: g)
instance (Optics.Internal.Indexed.TraversableWithIndex i f, Optics.Internal.Indexed.TraversableWithIndex j g) => Optics.Internal.Indexed.TraversableWithIndex (Data.Either.Either i j) (f GHC.Generics.:+: g)
instance Optics.Internal.Indexed.FunctorWithIndex i f => Optics.Internal.Indexed.FunctorWithIndex i (GHC.Generics.Rec1 f)
instance Optics.Internal.Indexed.FoldableWithIndex i f => Optics.Internal.Indexed.FoldableWithIndex i (GHC.Generics.Rec1 f)
instance Optics.Internal.Indexed.TraversableWithIndex i f => Optics.Internal.Indexed.TraversableWithIndex i (GHC.Generics.Rec1 f)
instance Optics.Internal.Indexed.FunctorWithIndex Data.Void.Void (GHC.Generics.K1 i c)
instance Optics.Internal.Indexed.FoldableWithIndex Data.Void.Void (GHC.Generics.K1 i c)
instance Optics.Internal.Indexed.TraversableWithIndex Data.Void.Void (GHC.Generics.K1 i c)
instance GHC.Base.Functor f => GHC.Base.Functor (Optics.Internal.Indexed.Indexing f)
instance GHC.Base.Applicative f => GHC.Base.Applicative (Optics.Internal.Indexed.Indexing f)
instance ((TypeError ...), is Data.Type.Equality.~ '[i1, i2], is Data.Type.Equality.~ '[i]) => Optics.Internal.Indexed.HasSingleIndex '[i1, i2] i
instance ((TypeError ...), is Data.Type.Equality.~ '[i1, i2, i3], is Data.Type.Equality.~ '[i]) => Optics.Internal.Indexed.HasSingleIndex '[i1, i2, i3] i
instance ((TypeError ...), is Data.Type.Equality.~ '[i1, i2, i3, i4], is Data.Type.Equality.~ '[i]) => Optics.Internal.Indexed.HasSingleIndex '[i1, i2, i3, i4] i
instance ((TypeError ...), is Data.Type.Equality.~ '[i1, i2, i3, i4, i5], is Data.Type.Equality.~ '[i]) => Optics.Internal.Indexed.HasSingleIndex '[i1, i2, i3, i4, i5] i
instance ((TypeError ...), is Data.Type.Equality.~ (i1 : i2 : i3 : i4 : i5 : i6 : is'), is Data.Type.Equality.~ '[i]) => Optics.Internal.Indexed.HasSingleIndex (i1 : i2 : i3 : i4 : i5 : i6 : is') i
instance Optics.Internal.Indexed.HasSingleIndex '[i] i
instance ((TypeError ...), '[] Data.Type.Equality.~ '[i]) => Optics.Internal.Indexed.HasSingleIndex '[] i
instance (TypeError ...) => Optics.Internal.Indexed.NonEmptyIndices '[]
instance Optics.Internal.Indexed.NonEmptyIndices (x : xs)
instance ((TypeError ...), (x : xs) Data.Type.Equality.~ Optics.Internal.Optic.TypeLevel.NoIx) => Optics.Internal.Indexed.AcceptsEmptyIndices f (x : xs)
instance Optics.Internal.Indexed.AcceptsEmptyIndices f '[]


-- | Internal implementation details of indexed setters.
--   
--   This module is intended for internal use only, and may change without
--   warning in subsequent releases.
module Optics.Internal.IxSetter

-- | Internal implementation of <a>imapped</a>.
imapped__ :: (Mapping p, FunctorWithIndex i f) => Optic__ p j (i -> j) (f a) (f b) a b


-- | Internal implementation details of indexed folds.
--   
--   This module is intended for internal use only, and may change without
--   warning in subsequent releases.
module Optics.Internal.IxFold

-- | Internal implementation of <a>ifoldVL</a>.
ifoldVL__ :: (Bicontravariant p, Traversing p) => (forall f. Applicative f => (i -> a -> f u) -> s -> f v) -> Optic__ p j (i -> j) s t a b

-- | Internal implementation of <a>ifolded</a>.
ifolded__ :: (Bicontravariant p, Traversing p, FoldableWithIndex i f) => Optic__ p j (i -> j) (f a) t a b

-- | Internal implementation of <a>ifoldring</a>.
ifoldring__ :: (Bicontravariant p, Traversing p) => (forall f. Applicative f => (i -> a -> f u -> f u) -> f v -> s -> f w) -> Optic__ p j (i -> j) s t a b


-- | Internal implementation details of indexed traversals.
--   
--   This module is intended for internal use only, and may change without
--   warning in subsequent releases.
module Optics.Internal.IxTraversal

-- | Internal implementation of <a>itraversed</a>.
itraversed__ :: (Traversing p, TraversableWithIndex i f) => Optic__ p j (i -> j) (f a) (f b) a b


-- | A <tt><a>Fold</a> S A</tt> has the ability to extract some number of
--   elements of type <tt>A</tt> from a container of type <tt>S</tt>. For
--   example, <a>toListOf</a> can be used to obtain the contained elements
--   as a list. Unlike a <a>Traversal</a>, there is no way to set or update
--   elements.
--   
--   This can be seen as a generalisation of <a>traverse_</a>, where the
--   type <tt>S</tt> does not need to be a type constructor with <tt>A</tt>
--   as the last parameter.
--   
--   A close relative is the <a>AffineFold</a>, which is a <a>Fold</a> that
--   contains at most one element.
module Optics.Fold

-- | Type synonym for a fold.
type Fold s a = Optic' A_Fold NoIx s a

-- | Obtain a <a>Fold</a> by lifting <a>traverse_</a> like function.
--   
--   <pre>
--   <a>foldVL</a> <a>.</a> <a>traverseOf_</a> ≡ <a>id</a>
--   <a>traverseOf_</a> <a>.</a> <a>foldVL</a> ≡ <a>id</a>
--   </pre>
foldVL :: (forall f. Applicative f => (a -> f u) -> s -> f v) -> Fold s a

-- | Combine the results of a fold using a monoid.
foldOf :: (Is k A_Fold, Monoid a) => Optic' k is s a -> s -> a

-- | Fold via embedding into a monoid.
foldMapOf :: (Is k A_Fold, Monoid m) => Optic' k is s a -> (a -> m) -> s -> m

-- | Fold right-associatively.
foldrOf :: Is k A_Fold => Optic' k is s a -> (a -> r -> r) -> r -> s -> r

-- | Fold left-associatively, and strictly.
foldlOf' :: Is k A_Fold => Optic' k is s a -> (r -> a -> r) -> r -> s -> r

-- | Fold to a list.
toListOf :: Is k A_Fold => Optic' k is s a -> s -> [a]

-- | Evaluate each action in a structure observed by a <a>Fold</a> from
--   left to right, ignoring the results.
--   
--   <pre>
--   <a>sequenceA_</a> ≡ <a>sequenceOf_</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; sequenceOf_ each (putStrLn "hello",putStrLn "world")
--   hello
--   world
--   </pre>
sequenceOf_ :: (Is k A_Fold, Applicative f) => Optic' k is s (f a) -> s -> f ()

-- | Traverse over all of the targets of a <a>Fold</a>, computing an
--   <a>Applicative</a>-based answer, but unlike <a>traverseOf</a> do not
--   construct a new structure. <a>traverseOf_</a> generalizes
--   <a>traverse_</a> to work over any <a>Fold</a>.
--   
--   <pre>
--   &gt;&gt;&gt; traverseOf_ each putStrLn ("hello","world")
--   hello
--   world
--   </pre>
--   
--   <pre>
--   <a>traverse_</a> ≡ <a>traverseOf_</a> <a>folded</a>
--   </pre>
traverseOf_ :: (Is k A_Fold, Applicative f) => Optic' k is s a -> (a -> f r) -> s -> f ()

-- | A version of <a>traverseOf_</a> with the arguments flipped.
forOf_ :: (Is k A_Fold, Applicative f) => Optic' k is s a -> s -> (a -> f r) -> f ()

-- | Fold via the <a>Foldable</a> class.
folded :: Foldable f => Fold (f a) a

-- | Obtain a <a>Fold</a> by lifting an operation that returns a
--   <a>Foldable</a> result.
--   
--   This can be useful to lift operations from <tt>Data.List</tt> and
--   elsewhere into a <a>Fold</a>.
--   
--   <pre>
--   &gt;&gt;&gt; toListOf (folding tail) [1,2,3,4]
--   [2,3,4]
--   </pre>
folding :: Foldable f => (s -> f a) -> Fold s a

-- | Obtain a <a>Fold</a> by lifting <a>foldr</a> like function.
--   
--   <pre>
--   &gt;&gt;&gt; toListOf (foldring foldr) [1,2,3,4]
--   [1,2,3,4]
--   </pre>
foldring :: (forall f. Applicative f => (a -> f u -> f u) -> f v -> s -> f w) -> Fold s a

-- | Build a <a>Fold</a> that unfolds its values from a seed.
--   
--   <pre>
--   <a>unfoldr</a> ≡ <a>toListOf</a> <a>.</a> <a>unfolded</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toListOf (unfolded $ \b -&gt; if b == 0 then Nothing else Just (b, b - 1)) 10
--   [10,9,8,7,6,5,4,3,2,1]
--   </pre>
unfolded :: (s -> Maybe (a, s)) -> Fold s a

-- | Check to see if this optic matches 1 or more entries.
--   
--   <pre>
--   &gt;&gt;&gt; has _Left (Left 12)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; has _Right (Left 12)
--   False
--   </pre>
--   
--   This will always return <a>True</a> for a <a>Lens</a> or
--   <a>Getter</a>.
--   
--   <pre>
--   &gt;&gt;&gt; has _1 ("hello","world")
--   True
--   </pre>
has :: Is k A_Fold => Optic' k is s a -> s -> Bool

-- | Check to see if this <a>Fold</a> or <a>Traversal</a> has no matches.
--   
--   <pre>
--   &gt;&gt;&gt; hasn't _Left (Right 12)
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; hasn't _Left (Left 12)
--   False
--   </pre>
hasn't :: Is k A_Fold => Optic' k is s a -> s -> Bool

-- | Retrieve the first entry of a <a>Fold</a>.
--   
--   <pre>
--   &gt;&gt;&gt; headOf folded [1..10]
--   Just 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; headOf each (1,2)
--   Just 1
--   </pre>
headOf :: Is k A_Fold => Optic' k is s a -> s -> Maybe a

-- | Retrieve the last entry of a <a>Fold</a>.
--   
--   <pre>
--   &gt;&gt;&gt; lastOf folded [1..10]
--   Just 10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lastOf each (1,2)
--   Just 2
--   </pre>
lastOf :: Is k A_Fold => Optic' k is s a -> s -> Maybe a

-- | Returns <a>True</a> if every target of a <a>Fold</a> is <a>True</a>.
--   
--   <pre>
--   &gt;&gt;&gt; andOf each (True, False)
--   False
--   
--   &gt;&gt;&gt; andOf each (True, True)
--   True
--   </pre>
--   
--   <pre>
--   <a>and</a> ≡ <a>andOf</a> <a>folded</a>
--   </pre>
andOf :: Is k A_Fold => Optic' k is s Bool -> s -> Bool

-- | Returns <a>True</a> if any target of a <a>Fold</a> is <a>True</a>.
--   
--   <pre>
--   &gt;&gt;&gt; orOf each (True, False)
--   True
--   
--   &gt;&gt;&gt; orOf each (False, False)
--   False
--   </pre>
--   
--   <pre>
--   <a>or</a> ≡ <a>orOf</a> <a>folded</a>
--   </pre>
orOf :: Is k A_Fold => Optic' k is s Bool -> s -> Bool

-- | Returns <a>True</a> if every target of a <a>Fold</a> satisfies a
--   predicate.
--   
--   <pre>
--   &gt;&gt;&gt; allOf each (&gt;=3) (4,5)
--   True
--   
--   &gt;&gt;&gt; allOf folded (&gt;=2) [1..10]
--   False
--   </pre>
--   
--   <pre>
--   <a>all</a> ≡ <a>allOf</a> <a>folded</a>
--   </pre>
allOf :: Is k A_Fold => Optic' k is s a -> (a -> Bool) -> s -> Bool

-- | Returns <a>True</a> if any target of a <a>Fold</a> satisfies a
--   predicate.
--   
--   <pre>
--   &gt;&gt;&gt; anyOf each (=='x') ('x','y')
--   True
--   </pre>
anyOf :: Is k A_Fold => Optic' k is s a -> (a -> Bool) -> s -> Bool

-- | Returns <a>True</a> only if no targets of a <a>Fold</a> satisfy a
--   predicate.
--   
--   <pre>
--   &gt;&gt;&gt; noneOf each (not . isn't _Nothing) (Just 3, Just 4, Just 5)
--   True
--   
--   &gt;&gt;&gt; noneOf (folded % folded) (&lt;10) [[13,99,20],[3,71,42]]
--   False
--   </pre>
noneOf :: Is k A_Fold => Optic' k is s a -> (a -> Bool) -> s -> Bool

-- | Calculate the <a>Product</a> of every number targeted by a
--   <a>Fold</a>.
--   
--   <pre>
--   &gt;&gt;&gt; productOf each (4,5)
--   20
--   
--   &gt;&gt;&gt; productOf folded [1,2,3,4,5]
--   120
--   </pre>
--   
--   <pre>
--   <a>product</a> ≡ <a>productOf</a> <a>folded</a>
--   </pre>
--   
--   This operation may be more strict than you would expect. If you want a
--   lazier version use <tt>\o -&gt; <a>getProduct</a> <a>.</a>
--   <a>foldMapOf</a> o <a>Product</a></tt>.
productOf :: (Is k A_Fold, Num a) => Optic' k is s a -> s -> a

-- | Calculate the <a>Sum</a> of every number targeted by a <a>Fold</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sumOf each (5,6)
--   11
--   
--   &gt;&gt;&gt; sumOf folded [1,2,3,4]
--   10
--   
--   &gt;&gt;&gt; sumOf (folded % each) [(1,2),(3,4)]
--   10
--   </pre>
--   
--   <pre>
--   <a>sum</a> ≡ <a>sumOf</a> <a>folded</a>
--   </pre>
--   
--   This operation may be more strict than you would expect. If you want a
--   lazier version use <tt>\o -&gt; <a>getSum</a> <a>.</a>
--   <a>foldMapOf</a> o <a>Sum</a></tt>
sumOf :: (Is k A_Fold, Num a) => Optic' k is s a -> s -> a

-- | The sum of a collection of actions.
--   
--   <pre>
--   &gt;&gt;&gt; asumOf each ("hello","world")
--   "helloworld"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; asumOf each (Nothing, Just "hello", Nothing)
--   Just "hello"
--   </pre>
--   
--   <pre>
--   <a>asum</a> ≡ <a>asumOf</a> <a>folded</a>
--   </pre>
asumOf :: (Is k A_Fold, Alternative f) => Optic' k is s (f a) -> s -> f a

-- | The sum of a collection of actions.
--   
--   <pre>
--   &gt;&gt;&gt; msumOf each ("hello","world")
--   "helloworld"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; msumOf each (Nothing, Just "hello", Nothing)
--   Just "hello"
--   </pre>
--   
--   <pre>
--   <a>msum</a> ≡ <a>msumOf</a> <a>folded</a>
--   </pre>
msumOf :: (Is k A_Fold, MonadPlus m) => Optic' k is s (m a) -> s -> m a

-- | Does the element occur anywhere within a given <a>Fold</a> of the
--   structure?
--   
--   <pre>
--   &gt;&gt;&gt; elemOf each "hello" ("hello","world")
--   True
--   </pre>
--   
--   <pre>
--   <a>elem</a> ≡ <a>elemOf</a> <a>folded</a>
--   </pre>
elemOf :: (Is k A_Fold, Eq a) => Optic' k is s a -> a -> s -> Bool

-- | Does the element not occur anywhere within a given <a>Fold</a> of the
--   structure?
--   
--   <pre>
--   &gt;&gt;&gt; notElemOf each 'd' ('a','b','c')
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; notElemOf each 'a' ('a','b','c')
--   False
--   </pre>
--   
--   <pre>
--   <a>notElem</a> ≡ <a>notElemOf</a> <a>folded</a>
--   </pre>
notElemOf :: (Is k A_Fold, Eq a) => Optic' k is s a -> a -> s -> Bool

-- | Calculate the number of targets there are for a <a>Fold</a> in a given
--   container.
--   
--   <i>Note:</i> This can be rather inefficient for large containers and
--   just like <a>length</a>, this will not terminate for infinite folds.
--   
--   <pre>
--   <a>length</a> ≡ <a>lengthOf</a> <a>folded</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lengthOf _1 ("hello",())
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lengthOf folded [1..10]
--   10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lengthOf (folded % folded) [[1,2],[3,4],[5,6]]
--   6
--   </pre>
lengthOf :: Is k A_Fold => Optic' k is s a -> s -> Int

-- | Obtain the maximum element (if any) targeted by a <a>Fold</a> safely.
--   
--   Note: <a>maximumOf</a> on a valid <a>Iso</a>, <a>Lens</a> or
--   <a>Getter</a> will always return <a>Just</a> a value.
--   
--   <pre>
--   &gt;&gt;&gt; maximumOf folded [1..10]
--   Just 10
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximumOf folded []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; maximumOf (folded % filtered even) [1,4,3,6,7,9,2]
--   Just 6
--   </pre>
--   
--   <pre>
--   <a>maximum</a> ≡ <a>fromMaybe</a> (<a>error</a> "empty") <a>.</a> <a>maximumOf</a> <a>folded</a>
--   </pre>
--   
--   In the interest of efficiency, This operation has semantics more
--   strict than strictly necessary. <tt>\o -&gt; <a>getMax</a> .
--   <a>foldMapOf</a> o <a>Max</a></tt> has lazier semantics but could leak
--   memory.
maximumOf :: (Is k A_Fold, Ord a) => Optic' k is s a -> s -> Maybe a

-- | Obtain the minimum element (if any) targeted by a <a>Fold</a> safely.
--   
--   Note: <a>minimumOf</a> on a valid <a>Iso</a>, <a>Lens</a> or
--   <a>Getter</a> will always return <a>Just</a> a value.
--   
--   <pre>
--   &gt;&gt;&gt; minimumOf folded [1..10]
--   Just 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimumOf folded []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; minimumOf (folded % filtered even) [1,4,3,6,7,9,2]
--   Just 2
--   </pre>
--   
--   <pre>
--   <a>minimum</a> ≡ <a>fromMaybe</a> (<a>error</a> "empty") <a>.</a> <a>minimumOf</a> <a>folded</a>
--   </pre>
--   
--   In the interest of efficiency, This operation has semantics more
--   strict than strictly necessary. <tt>\o -&gt; <a>getMin</a> .
--   <a>foldMapOf</a> o <a>Min</a></tt> has lazier semantics but could leak
--   memory.
minimumOf :: (Is k A_Fold, Ord a) => Optic' k is s a -> s -> Maybe a

-- | Obtain the maximum element (if any) targeted by a <a>Fold</a>
--   according to a user supplied <a>Ordering</a>.
--   
--   <pre>
--   &gt;&gt;&gt; maximumByOf folded (compare `on` length) ["mustard","relish","ham"]
--   Just "mustard"
--   </pre>
--   
--   In the interest of efficiency, This operation has semantics more
--   strict than strictly necessary.
--   
--   <pre>
--   <a>maximumBy</a> cmp ≡ <a>fromMaybe</a> (<a>error</a> "empty") <a>.</a> <a>maximumByOf</a> <a>folded</a> cmp
--   </pre>
maximumByOf :: Is k A_Fold => Optic' k is s a -> (a -> a -> Ordering) -> s -> Maybe a

-- | Obtain the minimum element (if any) targeted by a <a>Fold</a>
--   according to a user supplied <a>Ordering</a>.
--   
--   In the interest of efficiency, This operation has semantics more
--   strict than strictly necessary.
--   
--   <pre>
--   &gt;&gt;&gt; minimumByOf folded (compare `on` length) ["mustard","relish","ham"]
--   Just "ham"
--   </pre>
--   
--   <pre>
--   <a>minimumBy</a> cmp ≡ <a>fromMaybe</a> (<a>error</a> "empty") <a>.</a> <a>minimumByOf</a> <a>folded</a> cmp
--   </pre>
minimumByOf :: Is k A_Fold => Optic' k is s a -> (a -> a -> Ordering) -> s -> Maybe a

-- | The <a>findOf</a> function takes a <a>Fold</a>, a predicate and a
--   structure and returns the leftmost element of the structure matching
--   the predicate, or <a>Nothing</a> if there is no such element.
--   
--   <pre>
--   &gt;&gt;&gt; findOf each even (1,3,4,6)
--   Just 4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; findOf folded even [1,3,5,7]
--   Nothing
--   </pre>
--   
--   <pre>
--   <a>find</a> ≡ <a>findOf</a> <a>folded</a>
--   </pre>
findOf :: Is k A_Fold => Optic' k is s a -> (a -> Bool) -> s -> Maybe a

-- | The <a>findMOf</a> function takes a <a>Fold</a>, a monadic predicate
--   and a structure and returns in the monad the leftmost element of the
--   structure matching the predicate, or <a>Nothing</a> if there is no
--   such element.
--   
--   <pre>
--   &gt;&gt;&gt; findMOf each (\x -&gt; print ("Checking " ++ show x) &gt;&gt; return (even x)) (1,3,4,6)
--   "Checking 1"
--   "Checking 3"
--   "Checking 4"
--   Just 4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; findMOf each (\x -&gt; print ("Checking " ++ show x) &gt;&gt; return (even x)) (1,3,5,7)
--   "Checking 1"
--   "Checking 3"
--   "Checking 5"
--   "Checking 7"
--   Nothing
--   </pre>
--   
--   <pre>
--   <a>findMOf</a> <a>folded</a> :: (Monad m, Foldable f) =&gt; (a -&gt; m Bool) -&gt; f a -&gt; m (Maybe a)
--   </pre>
findMOf :: (Is k A_Fold, Monad m) => Optic' k is s a -> (a -> m Bool) -> s -> m (Maybe a)

-- | The <a>lookupOf</a> function takes a <a>Fold</a>, a key, and a
--   structure containing key/value pairs. It returns the first value
--   corresponding to the given key. This function generalizes
--   <a>lookup</a> to work on an arbitrary <a>Fold</a> instead of lists.
--   
--   <pre>
--   &gt;&gt;&gt; lookupOf folded 4 [(2, 'a'), (4, 'b'), (4, 'c')]
--   Just 'b'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; lookupOf folded 2 [(2, 'a'), (4, 'b'), (4, 'c')]
--   Just 'a'
--   </pre>
lookupOf :: (Is k A_Fold, Eq a) => Optic' k is s (a, v) -> a -> s -> Maybe v

-- | Convert a fold to an <a>AffineFold</a> that visits the first element
--   of the original fold.
pre :: Is k A_Fold => Optic' k is s a -> AffineFold s a

-- | This allows you to traverse the elements of a <a>Fold</a> in the
--   opposite order.
backwards_ :: Is k A_Fold => Optic' k is s a -> Fold s a

-- | Return entries of the first <a>Fold</a>, then the second one.
--   
--   <pre>
--   &gt;&gt;&gt; toListOf (_1 % ix 0 `summing` _2 % ix 1) ([1,2], [4,7,1])
--   [1,7]
--   </pre>
summing :: (Is k A_Fold, Is l A_Fold) => Optic' k is s a -> Optic' l js s a -> Fold s a
infixr 6 `summing`

-- | Try the first <a>Fold</a>. If it returns no entries, try the second
--   one.
failing :: (Is k A_Fold, Is l A_Fold) => Optic' k is s a -> Optic' l js s a -> Fold s a
infixl 3 `failing`

-- | Tag for a fold.
data A_Fold :: OpticKind


-- | An <a>IxAffineFold</a> is an indexed version of an <a>AffineFold</a>.
--   See the "Indexed optics" section of the overview documentation in the
--   <tt>Optics</tt> module of the main <tt>optics</tt> package for more
--   details on indexed optics.
module Optics.IxAffineFold

-- | Type synonym for an indexed affine fold.
type IxAffineFold i s a = Optic' An_AffineFold (WithIx i) s a

-- | Create an <a>IxAffineFold</a> from a partial function.
iafolding :: (s -> Maybe (i, a)) -> IxAffineFold i s a

-- | Retrieve the value along with its index targeted by an
--   <a>IxAffineFold</a>.
ipreview :: (Is k An_AffineFold, is `HasSingleIndex` i) => Optic' k is s a -> s -> Maybe (i, a)

-- | Retrieve a function of the value and its index targeted by an
--   <a>IxAffineFold</a>.
ipreviews :: (Is k An_AffineFold, is `HasSingleIndex` i) => Optic' k is s a -> (i -> a -> r) -> s -> Maybe r

-- | Try the first <a>IxAffineFold</a>. If it returns no entry, try the
--   second one.
--   
--   <i>Note:</i> There is no <a>isumming</a> equivalent, because
--   <tt>iasumming = iafailing</tt>.
iafailing :: (Is k An_AffineFold, Is l An_AffineFold, is1 `HasSingleIndex` i, is2 `HasSingleIndex` i) => Optic' k is1 s a -> Optic' l is2 s a -> IxAffineFold i s a
infixl 3 `iafailing`

-- | Tag for an affine fold.
data An_AffineFold :: OpticKind


-- | An <a>IxAffineTraversal</a> is an indexed version of an
--   <a>AffineTraversal</a>. See the "Indexed optics" section of the
--   overview documentation in the <tt>Optics</tt> module of the main
--   <tt>optics</tt> package for more details on indexed optics.
module Optics.IxAffineTraversal

-- | Type synonym for a type-modifying indexed affine traversal.
type IxAffineTraversal i s t a b = Optic An_AffineTraversal (WithIx i) s t a b

-- | Type synonym for a type-preserving indexed affine traversal.
type IxAffineTraversal' i s a = Optic' An_AffineTraversal (WithIx i) s a

-- | Build an indexed affine traversal from a matcher and an updater.
--   
--   If you want to build an <a>IxAffineTraversal</a> from the van
--   Laarhoven representation, use <a>iatraversalVL</a>.
iatraversal :: (s -> Either t (i, a)) -> (s -> b -> t) -> IxAffineTraversal i s t a b

-- | Tag for an affine traversal.
data An_AffineTraversal :: OpticKind

-- | Type synonym for a type-modifying van Laarhoven indexed affine
--   traversal.
--   
--   Note: this isn't exactly van Laarhoven representation as there is no
--   <tt>Pointed</tt> class (which would be a superclass of
--   <a>Applicative</a> that contains <a>pure</a> but not
--   <a>&lt;*&gt;</a>). You can interpret the first argument as a
--   dictionary of <tt>Pointed</tt> that supplies the <tt>point</tt>
--   function (i.e. the implementation of <a>pure</a>).
type IxAffineTraversalVL i s t a b = forall f. Functor f => (forall r. r -> f r) -> (i -> a -> f b) -> s -> f t

-- | Type synonym for a type-preserving van Laarhoven indexed affine
--   traversal.
type IxAffineTraversalVL' i s a = IxAffineTraversalVL i s s a a

-- | Build an indexed affine traversal from the van Laarhoven
--   representation.
iatraversalVL :: IxAffineTraversalVL i s t a b -> IxAffineTraversal i s t a b

-- | Convert an indexed affine traversal to its van Laarhoven
--   representation.
toIxAtraversalVL :: (Is k An_AffineTraversal, is `HasSingleIndex` i) => Optic k is s t a b -> IxAffineTraversalVL i s t a b


-- | An <a>IxFold</a> is an indexed version of a <a>Fold</a>. See the
--   "Indexed optics" section of the overview documentation in the
--   <tt>Optics</tt> module of the main <tt>optics</tt> package for more
--   details on indexed optics.
module Optics.IxFold

-- | Type synonym for an indexed fold.
type IxFold i s a = Optic' A_Fold (WithIx i) s a

-- | Obtain an indexed fold by lifting <a>itraverse_</a> like function.
--   
--   <pre>
--   <a>ifoldVL</a> <a>.</a> <a>itraverseOf_</a> ≡ <a>id</a>
--   <a>itraverseOf_</a> <a>.</a> <a>ifoldVL</a> ≡ <a>id</a>
--   </pre>
ifoldVL :: (forall f. Applicative f => (i -> a -> f u) -> s -> f v) -> IxFold i s a

-- | Fold with index via embedding into a monoid.
ifoldMapOf :: (Is k A_Fold, Monoid m, is `HasSingleIndex` i) => Optic' k is s a -> (i -> a -> m) -> s -> m

-- | Fold with index right-associatively.
ifoldrOf :: (Is k A_Fold, is `HasSingleIndex` i) => Optic' k is s a -> (i -> a -> r -> r) -> r -> s -> r

-- | Fold with index left-associatively, and strictly.
ifoldlOf' :: (Is k A_Fold, is `HasSingleIndex` i) => Optic' k is s a -> (i -> r -> a -> r) -> r -> s -> r

-- | Fold with index to a list.
--   
--   <pre>
--   &gt;&gt;&gt; itoListOf (folded % ifolded) ["abc", "def"]
--   [(0,'a'),(1,'b'),(2,'c'),(0,'d'),(1,'e'),(2,'f')]
--   </pre>
--   
--   <i>Note:</i> currently indexed optics can be used as non-indexed.
--   
--   <pre>
--   &gt;&gt;&gt; toListOf (folded % ifolded) ["abc", "def"]
--   "abcdef"
--   </pre>
itoListOf :: (Is k A_Fold, is `HasSingleIndex` i) => Optic' k is s a -> s -> [(i, a)]

-- | Traverse over all of the targets of an <a>IxFold</a>, computing an
--   <a>Applicative</a>-based answer, but unlike <a>itraverseOf</a> do not
--   construct a new structure.
--   
--   <pre>
--   &gt;&gt;&gt; itraverseOf_ each (curry print) ("hello","world")
--   (0,"hello")
--   (1,"world")
--   </pre>
itraverseOf_ :: (Is k A_Fold, Applicative f, is `HasSingleIndex` i) => Optic' k is s a -> (i -> a -> f r) -> s -> f ()

-- | A version of <a>itraverseOf_</a> with the arguments flipped.
iforOf_ :: (Is k A_Fold, Applicative f, is `HasSingleIndex` i) => Optic' k is s a -> s -> (i -> a -> f r) -> f ()

-- | Indexed fold via <a>FoldableWithIndex</a> class.
ifolded :: FoldableWithIndex i f => IxFold i (f a) a

-- | Obtain an <a>IxFold</a> by lifting an operation that returns a
--   <a>FoldableWithIndex</a> result.
--   
--   This can be useful to lift operations from <tt>Data.List</tt> and
--   elsewhere into an <a>IxFold</a>.
--   
--   <pre>
--   &gt;&gt;&gt; itoListOf (ifolding words) "how are you"
--   [(0,"how"),(1,"are"),(2,"you")]
--   </pre>
ifolding :: FoldableWithIndex i f => (s -> f a) -> IxFold i s a

-- | Obtain an <a>IxFold</a> by lifting <a>ifoldr</a> like function.
--   
--   <pre>
--   &gt;&gt;&gt; itoListOf (ifoldring ifoldr) "hello"
--   [(0,'h'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
--   </pre>
ifoldring :: (forall f. Applicative f => (i -> a -> f u -> f u) -> f v -> s -> f w) -> IxFold i s a

-- | Retrieve the first entry of an <a>IxFold</a> along with its index.
--   
--   <pre>
--   &gt;&gt;&gt; iheadOf ifolded [1..10]
--   Just (0,1)
--   </pre>
iheadOf :: (Is k A_Fold, is `HasSingleIndex` i) => Optic' k is s a -> s -> Maybe (i, a)

-- | Retrieve the last entry of an <a>IxFold</a> along with its index.
--   
--   <pre>
--   &gt;&gt;&gt; ilastOf ifolded [1..10]
--   Just (9,10)
--   </pre>
ilastOf :: (Is k A_Fold, is `HasSingleIndex` i) => Optic' k is s a -> s -> Maybe (i, a)

-- | Return whether or not any element viewed through an <a>IxFold</a>
--   satisfies a predicate, with access to the <tt>i</tt>.
--   
--   When you don't need access to the index then <a>anyOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>anyOf</a> o ≡ <a>ianyOf</a> o <a>.</a> <a>const</a>
--   </pre>
ianyOf :: (Is k A_Fold, is `HasSingleIndex` i) => Optic' k is s a -> (i -> a -> Bool) -> s -> Bool

-- | Return whether or not all elements viewed through an <a>IxFold</a>
--   satisfy a predicate, with access to the <tt>i</tt>.
--   
--   When you don't need access to the index then <a>allOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>allOf</a> o ≡ <a>iallOf</a> o <a>.</a> <a>const</a>
--   </pre>
iallOf :: (Is k A_Fold, is `HasSingleIndex` i) => Optic' k is s a -> (i -> a -> Bool) -> s -> Bool

-- | Return whether or not none of the elements viewed through an
--   <a>IxFold</a> satisfy a predicate, with access to the <tt>i</tt>.
--   
--   When you don't need access to the index then <a>noneOf</a> is more
--   flexible in what it accepts.
--   
--   <pre>
--   <a>noneOf</a> o ≡ <a>inoneOf</a> o <a>.</a> <a>const</a>
--   </pre>
inoneOf :: (Is k A_Fold, is `HasSingleIndex` i) => Optic' k is s a -> (i -> a -> Bool) -> s -> Bool

-- | The <a>ifindOf</a> function takes an <a>IxFold</a>, a predicate that
--   is also supplied the index, a structure and returns the left-most
--   element of the structure along with its index matching the predicate,
--   or <a>Nothing</a> if there is no such element.
--   
--   When you don't need access to the index then <a>findOf</a> is more
--   flexible in what it accepts.
ifindOf :: (Is k A_Fold, is `HasSingleIndex` i) => Optic' k is s a -> (i -> a -> Bool) -> s -> Maybe (i, a)

-- | The <a>ifindMOf</a> function takes an <a>IxFold</a>, a monadic
--   predicate that is also supplied the index, a structure and returns in
--   the monad the left-most element of the structure matching the
--   predicate, or <a>Nothing</a> if there is no such element.
--   
--   When you don't need access to the index then <a>findMOf</a> is more
--   flexible in what it accepts.
ifindMOf :: (Is k A_Fold, Monad m, is `HasSingleIndex` i) => Optic' k is s a -> (i -> a -> m Bool) -> s -> m (Maybe (i, a))

-- | Convert an indexed fold to an <a>IxAffineFold</a> that visits the
--   first element of the original fold.
ipre :: (Is k A_Fold, is `HasSingleIndex` i) => Optic' k is s a -> IxAffineFold i s a

-- | Filter results of an <a>IxFold</a> that don't satisfy a predicate.
--   
--   <pre>
--   &gt;&gt;&gt; toListOf (ifolded %&amp; ifiltered (&gt;)) [3,2,1,0]
--   [1,0]
--   </pre>
ifiltered :: (Is k A_Fold, is `HasSingleIndex` i) => (i -> a -> Bool) -> Optic' k is s a -> IxFold i s a

-- | This allows you to traverse the elements of an <a>IxFold</a> in the
--   opposite order.
ibackwards_ :: (Is k A_Fold, is `HasSingleIndex` i) => Optic' k is s a -> IxFold i s a

-- | Return entries of the first <a>IxFold</a>, then the second one.
isumming :: (Is k A_Fold, Is l A_Fold, is1 `HasSingleIndex` i, is2 `HasSingleIndex` i) => Optic' k is1 s a -> Optic' l is2 s a -> IxFold i s a
infixr 6 `isumming`

-- | Try the first <a>IxFold</a>. If it returns no entries, try the second
--   one.
ifailing :: (Is k A_Fold, Is l A_Fold, is1 `HasSingleIndex` i, is2 `HasSingleIndex` i) => Optic' k is1 s a -> Optic' l is2 s a -> IxFold i s a
infixl 3 `ifailing`

-- | Tag for a fold.
data A_Fold :: OpticKind

-- | Class for <a>Foldable</a>s that have an additional read-only index
--   available.
class (FunctorWithIndex i f, Foldable f) => FoldableWithIndex i f | f -> i
ifoldMap :: (FoldableWithIndex i f, Monoid m) => (i -> a -> m) -> f a -> m
ifoldMap :: (FoldableWithIndex i f, TraversableWithIndex i f, Monoid m) => (i -> a -> m) -> f a -> m
ifoldr :: FoldableWithIndex i f => (i -> a -> b -> b) -> b -> f a -> b
ifoldl' :: FoldableWithIndex i f => (i -> b -> a -> b) -> b -> f a -> b


-- | An <a>IxGetter</a> is an indexed version of a <a>Getter</a>. See the
--   "Indexed optics" section of the overview documentation in the
--   <tt>Optics</tt> module of the main <tt>optics</tt> package for more
--   details on indexed optics.
module Optics.IxGetter

-- | Type synonym for an indexed getter.
type IxGetter i s a = Optic' A_Getter (WithIx i) s a

-- | Build an indexed getter from a function.
--   
--   <pre>
--   &gt;&gt;&gt; iview (ito id) ('i', 'x')
--   ('i','x')
--   </pre>
ito :: (s -> (i, a)) -> IxGetter i s a

-- | Use a value itself as its own index. This is essentially an indexed
--   version of <a>equality</a>.
selfIndex :: IxGetter a a a

-- | View the value pointed to by an indexed getter.
iview :: (Is k A_Getter, is `HasSingleIndex` i) => Optic' k is s a -> s -> (i, a)

-- | View the function of the value pointed to by an indexed getter.
iviews :: (Is k A_Getter, is `HasSingleIndex` i) => Optic' k is s a -> (i -> a -> r) -> s -> r

-- | Tag for a getter.
data A_Getter :: OpticKind


-- | An <a>IxLens</a> is an indexed version of a <a>Lens</a>. See the
--   "Indexed optics" section of the overview documentation in the
--   <tt>Optics</tt> module of the main <tt>optics</tt> package for more
--   details on indexed optics.
module Optics.IxLens

-- | Type synonym for a type-modifying indexed lens.
type IxLens i s t a b = Optic A_Lens (WithIx i) s t a b

-- | Type synonym for a type-preserving indexed lens.
type IxLens' i s a = Optic' A_Lens (WithIx i) s a

-- | Build an indexed lens from a getter and a setter.
--   
--   If you want to build an <a>IxLens</a> from the van Laarhoven
--   representation, use <a>ilensVL</a>.
ilens :: (s -> (i, a)) -> (s -> b -> t) -> IxLens i s t a b

-- | There is an indexed field for every type in the <a>Void</a>.
--   
--   <pre>
--   &gt;&gt;&gt; set (mapped % devoid) 1 []
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over (_Just % devoid) abs Nothing
--   Nothing
--   </pre>
devoid :: IxLens' i Void a

-- | Tag for a lens.
data A_Lens :: OpticKind

-- | Type synonym for a type-modifying van Laarhoven indexed lens.
type IxLensVL i s t a b = forall f. Functor f => (i -> a -> f b) -> s -> f t

-- | Type synonym for a type-preserving van Laarhoven indexed lens.
type IxLensVL' i s a = IxLensVL i s s a a

-- | Build an indexed lens from the van Laarhoven representation.
ilensVL :: IxLensVL i s t a b -> IxLens i s t a b

-- | Convert an indexed lens to its van Laarhoven representation.
toIxLensVL :: (Is k A_Lens, is `HasSingleIndex` i) => Optic k is s t a b -> IxLensVL i s t a b

-- | Work with an indexed lens in the van Laarhoven representation.
withIxLensVL :: (Is k A_Lens, is `HasSingleIndex` i) => Optic k is s t a b -> (IxLensVL i s t a b -> r) -> r


-- | An <a>IxSetter</a> is an indexed version of a <a>Setter</a>. See the
--   "Indexed optics" section of the overview documentation in the
--   <tt>Optics</tt> module of the main <tt>optics</tt> package for more
--   details on indexed optics.
module Optics.IxSetter

-- | Type synonym for a type-modifying indexed setter.
type IxSetter i s t a b = Optic A_Setter (WithIx i) s t a b

-- | Type synonym for a type-preserving indexed setter.
type IxSetter' i s a = Optic' A_Setter (WithIx i) s a

-- | Build an indexed setter from a function to modify the element(s).
isets :: ((i -> a -> b) -> s -> t) -> IxSetter i s t a b

-- | Apply an indexed setter as a modifier.
iover :: (Is k A_Setter, is `HasSingleIndex` i) => Optic k is s t a b -> (i -> a -> b) -> s -> t

-- | Indexed setter via the <a>FunctorWithIndex</a> class.
--   
--   <pre>
--   <a>iover</a> <a>imapped</a> ≡ <a>imap</a>
--   </pre>
imapped :: FunctorWithIndex i f => IxSetter i (f a) (f b) a b

-- | Apply an indexed setter.
--   
--   <pre>
--   <a>iset</a> o f ≡ <a>iover</a> o (i _ -&gt; f i)
--   </pre>
iset :: (Is k A_Setter, is `HasSingleIndex` i) => Optic k is s t a b -> (i -> b) -> s -> t

-- | Apply an indexed setter, strictly.
iset' :: (Is k A_Setter, is `HasSingleIndex` i) => Optic k is s t a b -> (i -> b) -> s -> t

-- | Apply an indexed setter as a modifier, strictly.
iover' :: (Is k A_Setter, is `HasSingleIndex` i) => Optic k is s t a b -> (i -> a -> b) -> s -> t

-- | Tag for a setter.
data A_Setter :: OpticKind

-- | Class for <a>Functor</a>s that have an additional read-only index
--   available.
class Functor f => FunctorWithIndex i f | f -> i
imap :: FunctorWithIndex i f => (i -> a -> b) -> f a -> f b
imap :: (FunctorWithIndex i f, TraversableWithIndex i f) => (i -> a -> b) -> f a -> f b


-- | Overloaded labels are a solution to Haskell's namespace problem for
--   records. The <tt>-XOverloadedLabels</tt> extension allows a new
--   expression syntax for labels, a prefix <tt>#</tt> sign followed by an
--   identifier, e.g. <tt>#foo</tt>. These expressions can then be given an
--   interpretation that depends on the type at which they are used and the
--   text of the label.
--   
--   The following example shows how overloaded labels can be used as
--   optics.
--   
--   <h2>Example</h2>
--   
--   Consider the following:
--   
--   <pre>
--   &gt;&gt;&gt; :set -XDataKinds
--   
--   &gt;&gt;&gt; :set -XFlexibleContexts
--   
--   &gt;&gt;&gt; :set -XFlexibleInstances
--   
--   &gt;&gt;&gt; :set -XMultiParamTypeClasses
--   
--   &gt;&gt;&gt; :set -XOverloadedLabels
--   
--   &gt;&gt;&gt; :set -XTypeFamilies
--   
--   &gt;&gt;&gt; :set -XUndecidableInstances
--   
--   &gt;&gt;&gt; :{
--   data Human = Human
--     { humanName :: String
--     , humanAge  :: Integer
--     , humanPets :: [Pet]
--     } deriving Show
--   data Pet
--     = Cat  { petName :: String, petAge :: Int, petLazy :: Bool }
--     | Fish { petName :: String, petAge :: Int }
--     deriving Show
--   :}
--   </pre>
--   
--   The following instances can be generated by <tt>makeFieldLabels</tt>
--   from <tt>Optics.TH</tt> in the <tt>optics-th</tt> package:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   instance (a ~ String, b ~ String) =&gt; LabelOptic "name" A_Lens Human Human a b where
--     labelOptic = lensVL $ \f s -&gt; (\v -&gt; s { humanName = v }) &lt;$&gt; f (humanName s)
--   instance (a ~ Integer, b ~ Integer) =&gt; LabelOptic "age" A_Lens Human Human a b where
--     labelOptic = lensVL $ \f s -&gt; (\v -&gt; s { humanAge = v }) &lt;$&gt; f (humanAge s)
--   instance (a ~ [Pet], b ~ [Pet]) =&gt; LabelOptic "pets" A_Lens Human Human a b where
--     labelOptic = lensVL $ \f s -&gt; (\v -&gt; s { humanPets = v }) &lt;$&gt; f (humanPets s)
--   instance (a ~ String, b ~ String) =&gt; LabelOptic "name" A_Lens Pet Pet a b where
--     labelOptic = lensVL $ \f s -&gt; (\v -&gt; s { petName = v }) &lt;$&gt; f (petName s)
--   instance (a ~ Int, b ~ Int) =&gt; LabelOptic "age" A_Lens Pet Pet a b where
--     labelOptic = lensVL $ \f s -&gt; (\v -&gt; s { petAge = v }) &lt;$&gt; f (petAge s)
--   instance (a ~ Bool, b ~ Bool) =&gt; LabelOptic "lazy" An_AffineTraversal Pet Pet a b where
--     labelOptic = atraversalVL $ \point f s -&gt; case s of
--       Cat name age lazy -&gt; (\lazy' -&gt; Cat name age lazy') &lt;$&gt; f lazy
--       _                 -&gt; point s
--   :}
--   </pre>
--   
--   Here is some test data:
--   
--   <pre>
--   &gt;&gt;&gt; :{
--   peter :: Human
--   peter = Human "Peter" 13 [ Fish "Goldie" 1
--                            , Cat  "Loopy"  3 False
--                            , Cat  "Sparky" 2 True
--                            ]
--   :}
--   </pre>
--   
--   Now we can ask for Peter's name:
--   
--   <pre>
--   &gt;&gt;&gt; view #name peter
--   "Peter"
--   </pre>
--   
--   or for names of his pets:
--   
--   <pre>
--   &gt;&gt;&gt; toListOf (#pets % folded % #name) peter
--   ["Goldie","Loopy","Sparky"]
--   </pre>
--   
--   We can check whether any of his pets is lazy:
--   
--   <pre>
--   &gt;&gt;&gt; orOf (#pets % folded % #lazy) peter
--   True
--   </pre>
--   
--   or how things might be be a year from now:
--   
--   <pre>
--   &gt;&gt;&gt; peter &amp; over #age (+1) &amp; over (#pets % mapped % #age) (+1)
--   Human {humanName = "Peter", humanAge = 14, humanPets = [Fish {petName = "Goldie", petAge = 2},Cat {petName = "Loopy", petAge = 4, petLazy = False},Cat {petName = "Sparky", petAge = 3, petLazy = True}]}
--   </pre>
--   
--   Perhaps Peter is going on vacation and needs to leave his pets at
--   home:
--   
--   <pre>
--   &gt;&gt;&gt; peter &amp; set #pets []
--   Human {humanName = "Peter", humanAge = 13, humanPets = []}
--   </pre>
--   
--   <h2>Structure of <a>LabelOptic</a> instances</h2>
--   
--   You might wonder why instances above are written in form
--   
--   <pre>
--   instance (a ~ [Pet], b ~ [Pet]) =&gt; LabelOptic "pets" A_Lens Human Human a b where
--   </pre>
--   
--   instead of
--   
--   <pre>
--   instance LabelOptic "pets" A_Lens Human Human [Pet] [Pet] where
--   </pre>
--   
--   The reason is that using the first form ensures that GHC always
--   matches on the instance if either <tt>s</tt> or <tt>t</tt> is known
--   and verifies type equalities later, which not only makes type
--   inference better, but also allows it to generate good error messages.
--   
--   For example, if you try to write <tt>peter &amp; set #pets []</tt>
--   with the appropriate LabelOptic instance in the second form, you get
--   the following:
--   
--   <pre>
--   <a>interactive</a>:16:1: error:
--      • No instance for LabelOptic "pets" ‘A_Lens’ ‘Human’ ‘()’ ‘[Pet]’ ‘[a0]’
--          (maybe you forgot to define it or misspelled a name?)
--      • In the first argument of ‘print’, namely ‘it’
--        In a stmt of an interactive GHCi command: print it
--   </pre>
--   
--   That's because empty list doesn't have type <tt>[Pet]</tt>, it has
--   type <tt>[r]</tt> and GHC doesn't have enough information to match on
--   the instance we provided. We'd need to either annotate the list:
--   <tt>peter &amp; set #pets ([]::[Pet])</tt> or the result type:
--   <tt>peter &amp; set #pets [] :: Human</tt>, which is suboptimal.
--   
--   Here are more examples of confusing error messages if the instance for
--   <tt>LabelOptic "age"</tt> is written without type equalities:
--   
--   <pre>
--   λ&gt; view #age peter :: Char
--   
--   <a>interactive</a>:28:6: error:
--       • No instance for LabelOptic "age" ‘k0’ ‘Human’ ‘Human’ ‘Char’ ‘Char’
--           (maybe you forgot to define it or misspelled a name?)
--       • In the first argument of ‘view’, namely ‘#age’
--         In the expression: view #age peter :: Char
--         In an equation for ‘it’: it = view #age peter :: Char
--   λ&gt; peter &amp; set #age "hi"
--   
--   <a>interactive</a>:29:1: error:
--       • No instance for LabelOptic "age" ‘k’ ‘Human’ ‘b’ ‘a’ ‘[Char]’
--           (maybe you forgot to define it or misspelled a name?)
--       • When checking the inferred type
--           it :: forall k b a. ((TypeError ...), Is k A_Setter) =&gt; b
--   </pre>
--   
--   If we use the first form, error messages become more accurate:
--   
--   <pre>
--   λ&gt; view #age peter :: Char
--   <a>interactive</a>:31:6: error:
--       • Couldn't match type ‘Char’ with ‘Integer’
--           arising from the overloaded label ‘#age’
--       • In the first argument of ‘view’, namely ‘#age’
--         In the expression: view #age peter :: Char
--         In an equation for ‘it’: it = view #age peter :: Char
--   λ&gt; peter &amp; set #age "hi"
--   
--   <a>interactive</a>:32:13: error:
--       • Couldn't match type ‘[Char]’ with ‘Integer’
--           arising from the overloaded label ‘#age’
--       • In the first argument of ‘set’, namely ‘#age’
--         In the second argument of ‘(&amp;)’, namely ‘set #age "hi"’
--         In the expression: peter &amp; set #age "hi"
--   </pre>
--   
--   <h2>Limitations arising from functional dependencies</h2>
--   
--   Functional dependencies guarantee good type inference, but also create
--   limitations. We can split them into two groups:
--   
--   <ul>
--   <li><tt>name s -&gt; k a</tt>, <tt>name t -&gt; k b</tt></li>
--   <li><tt>name s b -&gt; t</tt>, <tt>name t a -&gt; s</tt></li>
--   </ul>
--   
--   The first group ensures that when we compose two optics, the middle
--   type is unambiguous. The consequence is that it's not possible to
--   create label optics with <tt>a</tt> or <tt>b</tt> referencing type
--   variables not referenced in <tt>s</tt> or <tt>t</tt>, i.e. getters for
--   fields of rank 2 type or reviews for constructors with existentially
--   quantified types inside.
--   
--   The second group ensures that when we perform a chain of updates, the
--   middle type is unambiguous. The consequence is that it's not possible
--   to define label optics that:
--   
--   <ul>
--   <li>Modify phantom type parameters of type <tt>s</tt> or
--   <tt>t</tt>.</li>
--   <li>Modify type parameters of type <tt>s</tt> or <tt>t</tt> if
--   <tt>a</tt> or <tt>b</tt> contain ambiguous applications of type
--   families to these type parameters.</li>
--   </ul>
module Optics.Label

-- | Support for overloaded labels as optics. An overloaded label
--   <tt>#foo</tt> can be used as an optic if there is an instance of
--   <tt><a>LabelOptic</a> "foo" k s t a b</tt>.
--   
--   See <a>Optics.Label</a> for examples and further details.
class LabelOptic (name :: Symbol) k s t a b | name s -> k a, name t -> k b, name s b -> t, name t a -> s

-- | Used to interpret overloaded label syntax. An overloaded label
--   <tt>#foo</tt> corresponds to <tt><a>labelOptic</a> @"foo"</tt>.
labelOptic :: LabelOptic name k s t a b => Optic k NoIx s t a b

-- | Type synonym for a type-preserving optic as overloaded label.
type LabelOptic' name k s a = LabelOptic name k s s a a


-- | A <a>Lens</a> is a generalised or first-class field.
--   
--   If we have a value <tt>s :: S</tt>, and a <tt>l :: <a>Lens'</a> S
--   A</tt>, we can <i>get</i> the "field value" of type <tt>A</tt> using
--   <tt><a>view</a> l s</tt>. We can also <i>update</i> (or <i>put</i> or
--   <i>set</i>) the value using <a>over</a> (or <a>set</a>).
--   
--   For example, given the following definitions:
--   
--   <pre>
--   &gt;&gt;&gt; data Human = Human { _name :: String, _location :: String } deriving Show
--   
--   &gt;&gt;&gt; let human = Human "Bob" "London"
--   </pre>
--   
--   we can make a <a>Lens</a> for <tt>_name</tt> field:
--   
--   <pre>
--   &gt;&gt;&gt; let name = lens _name $ \s x -&gt; s { _name = x }
--   </pre>
--   
--   which we can use as a <a>Getter</a>:
--   
--   <pre>
--   &gt;&gt;&gt; view name human
--   "Bob"
--   </pre>
--   
--   or a <a>Setter</a>:
--   
--   <pre>
--   &gt;&gt;&gt; set name "Robert" human
--   Human {_name = "Robert", _location = "London"}
--   </pre>
module Optics.Lens

-- | Type synonym for a type-modifying lens.
type Lens s t a b = Optic A_Lens NoIx s t a b

-- | Type synonym for a type-preserving lens.
type Lens' s a = Optic' A_Lens NoIx s a

-- | Build a lens from a getter and a setter, which must respect the
--   well-formedness laws.
--   
--   If you want to build a <a>Lens</a> from the van Laarhoven
--   representation, use <a>lensVL</a>.
lens :: (s -> a) -> (s -> b -> t) -> Lens s t a b

-- | Strict version of <a>equality</a>.
--   
--   Useful for strictifying optics with lazy (irrefutable) pattern
--   matching by precomposition, e.g.
--   
--   <pre>
--   <a>_1'</a> = <a>equality'</a> % <a>_1</a>
--   </pre>
equality' :: Lens a b a b

-- | Focus on both sides of an <a>Either</a>.
chosen :: Lens (Either a a) (Either b b) a b

-- | Make a <a>Lens</a> from two other lenses by executing them on their
--   respective halves of a product.
--   
--   <pre>
--   &gt;&gt;&gt; (Left 'a', Right 'b') ^. alongside chosen chosen
--   ('a','b')
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (Left 'a', Right 'b') &amp; alongside chosen chosen .~ ('c','d')
--   (Left 'c',Right 'd')
--   </pre>
alongside :: (Is k A_Lens, Is l A_Lens) => Optic k is s t a b -> Optic l js s' t' a' b' -> Lens (s, s') (t, t') (a, a') (b, b')

-- | We can always retrieve a <tt>()</tt> from any type.
--   
--   <pre>
--   &gt;&gt;&gt; view united "hello"
--   ()
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; set united () "hello"
--   "hello"
--   </pre>
united :: Lens' a ()

-- | Work with a lens as a getter and a setter.
--   
--   <pre>
--   <a>withLens</a> (<a>lens</a> f g) k ≡ k f g
--   </pre>
withLens :: Is k A_Lens => Optic k is s t a b -> ((s -> a) -> (s -> b -> t) -> r) -> r

-- | Tag for a lens.
data A_Lens :: OpticKind

-- | Type synonym for a type-modifying van Laarhoven lens.
type LensVL s t a b = forall f. Functor f => (a -> f b) -> s -> f t

-- | Type synonym for a type-preserving van Laarhoven lens.
type LensVL' s a = LensVL s s a a

-- | Build a lens from the van Laarhoven representation.
lensVL :: LensVL s t a b -> Lens s t a b

-- | Convert a lens to the van Laarhoven representation.
toLensVL :: Is k A_Lens => Optic k is s t a b -> LensVL s t a b

-- | Work with a lens in the van Laarhoven representation.
withLensVL :: Is k A_Lens => Optic k is s t a b -> (LensVL s t a b -> r) -> r


-- | This module defines optics for manipulating <a>Tree</a>s.
module Data.Tree.Optics

-- | A <a>Lens</a> that focuses on the root of a <a>Tree</a>.
--   
--   <pre>
--   &gt;&gt;&gt; view root $ Node 42 []
--   42
--   </pre>
root :: Lens' (Tree a) a

-- | A <a>Lens</a> returning the direct descendants of the root of a
--   <a>Tree</a>
--   
--   <pre>
--   <a>view</a> <a>branches</a> ≡ <a>subForest</a>
--   </pre>
branches :: Lens' (Tree a) [Tree a]


-- | This module provides core definitions:
--   
--   <ul>
--   <li>an opaque <a>Optic</a> type, which is parameterised over a type
--   representing an optic kind (instantiated with tag types such as
--   <a>A_Lens</a>);</li>
--   <li>the optic composition operator (<a>%</a>);</li>
--   <li>the subtyping relation <a>Is</a> with an accompanying
--   <a>castOptic</a> function to convert an optic kind;</li>
--   <li>the <a>Join</a> operation used to find the optic kind resulting
--   from a composition.</li>
--   </ul>
--   
--   Each optic kind is identified by a "tag type" (such as <a>A_Lens</a>),
--   which is an empty data type. The type of the actual optics (such as
--   <a>Lens</a>) is obtained by applying <a>Optic</a> to the tag type.
--   
--   See the <tt>Optics</tt> module in the main <tt>optics</tt> package for
--   overview documentation.
module Optics.Optic

-- | Kind for types used as optic tags, such as <a>A_Lens</a>.
type OpticKind = Type

-- | Wrapper newtype for the whole family of optics.
--   
--   The first parameter <tt>k</tt> identifies the particular optic kind
--   (e.g. <a>A_Lens</a> or <a>A_Traversal</a>).
--   
--   The parameter <tt>is</tt> is a list of types available as indices.
--   This will typically be <a>NoIx</a> for unindexed optics, or
--   <a>WithIx</a> for optics with a single index. See the "Indexed optics"
--   section of the overview documentation in the <tt>Optics</tt> module of
--   the main <tt>optics</tt> package for more details.
--   
--   The parameters <tt>s</tt> and <tt>t</tt> represent the "big"
--   structure, whereas <tt>a</tt> and <tt>b</tt> represent the "small"
--   structure.
data Optic (k :: OpticKind) (is :: IxList) s t a b

-- | Common special case of <a>Optic</a> where source and target types are
--   equal.
--   
--   Here, we need only one "big" and one "small" type. For lenses, this
--   means that in the restricted form we cannot do type-changing updates.
type Optic' k is s a = Optic k is s s a a

-- | Explicit cast from one optic flavour to another.
--   
--   The resulting optic kind is given in the first type argument, so you
--   can use TypeApplications to set it. For example
--   
--   <pre>
--   <a>castOptic</a> @<a>A_Lens</a> o
--   </pre>
--   
--   turns <tt>o</tt> into a <a>Lens</a>.
--   
--   This is the identity function, modulo some constraint jiggery-pokery.
castOptic :: forall destKind srcKind is s t a b. Is srcKind destKind => Optic srcKind is s t a b -> Optic destKind is s t a b

-- | Subtyping relationship between kinds of optics.
--   
--   An instance of <tt><a>Is</a> k l</tt> means that any <tt><a>Optic</a>
--   k</tt> can be used as an <tt><a>Optic</a> l</tt>. For example, we have
--   an <tt><a>Is</a> <a>A_Lens</a> <a>A_Traversal</a></tt> instance, but
--   not <tt><a>Is</a> <a>A_Traversal</a> <a>A_Lens</a></tt>.
--   
--   This class needs instances for all possible combinations of tags.
class Is k l

-- | Computes the least upper bound of two optics kinds.
--   
--   <tt>Join k l</tt> represents the least upper bound of an <tt>Optic
--   k</tt> and an <tt>Optic l</tt>. This means in particular that
--   composition of an <tt>Optic k</tt> and an <tt>Optic k</tt> will yield
--   an <tt>Optic (Join k l)</tt>.
type family Join (k :: OpticKind) (l :: OpticKind)

-- | Compose two optics of compatible flavours.
--   
--   Returns an optic of the appropriate supertype. If either or both
--   optics are indexed, the composition preserves all the indices.
(%) :: (Is k m, Is l m, m ~ Join k l, ks ~ Append is js) => Optic k is s t u v -> Optic l js u v a b -> Optic m ks s t a b
infixl 9 %

-- | Compose two optics of the same flavour.
--   
--   Normally you can simply use (<a>%</a>) instead, but this may be useful
--   to help type inference if the type of one of the optics is otherwise
--   under-constrained.
(%%) :: forall k is js ks s t u v a b. ks ~ Append is js => Optic k is s t u v -> Optic k js u v a b -> Optic k ks s t a b
infixl 9 %%

-- | Flipped function application, specialised to optics and binding
--   tightly.
--   
--   Useful for post-composing optics transformations:
--   
--   <pre>
--   &gt;&gt;&gt; toListOf (ifolded %&amp; ifiltered (\i s -&gt; length s &lt;= i)) ["", "a","abc"]
--   ["","a"]
--   </pre>
(%&) :: Optic k is s t a b -> (Optic k is s t a b -> Optic l js s' t' a' b') -> Optic l js s' t' a' b'
infixl 9 %&

-- | A list of index types, used for indexed optics.
type IxList = [Type]

-- | An alias for an empty index-list
type NoIx = ('[] :: IxList)

-- | Singleton index list
type WithIx i = ('[i] :: IxList)

-- | Append two type-level lists together.
type family Append (xs :: IxList) (ys :: IxList) :: IxList

-- | Check whether a list of indices is not empty and generate sensible
--   error message if it's not.
class NonEmptyIndices (is :: IxList)

-- | Generate sensible error messages in case a user tries to pass either
--   an unindexed optic or indexed optic with unflattened indices where
--   indexed optic with a single index is expected.
class is ~ '[i] => HasSingleIndex (is :: IxList) (i :: Type)

-- | Show useful error message when a function expects optics without
--   indices.
class is ~ NoIx => AcceptsEmptyIndices (f :: Symbol) (is :: IxList)

-- | <a>&amp;</a> is a reverse application operator. This provides
--   notational convenience. Its precedence is one higher than that of the
--   forward application operator <a>$</a>, which allows <a>&amp;</a> to be
--   nested in <a>$</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 5 &amp; (+1) &amp; show
--   "6"
--   </pre>
(&) :: () => a -> (a -> b) -> b
infixl 1 &

-- | Flipped version of <a>&lt;$&gt;</a>.
--   
--   <pre>
--   (<a>&lt;&amp;&gt;</a>) = <a>flip</a> <a>fmap</a>
--   </pre>
--   
--   <h4><b>Examples</b></h4>
--   
--   Apply <tt>(+1)</tt> to a list, a <a>Just</a> and a <a>Right</a>:
--   
--   <pre>
--   &gt;&gt;&gt; Just 2 &lt;&amp;&gt; (+1)
--   Just 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &lt;&amp;&gt; (+1)
--   [2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Right 3 &lt;&amp;&gt; (+1)
--   Right 4
--   </pre>
(<&>) :: Functor f => f a -> (a -> b) -> f b
infixl 1 <&>


-- | This module exists to provide documentation for lenses for working
--   with <a>Map</a>, which might otherwise be obscured by their
--   genericity.
--   
--   <a>Map</a> is an instance of <a>At</a> and provides <a>at</a> as a
--   lens on values at keys:
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [(1, "world")] ^. at 1
--   Just "world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.empty &amp; at 1 .~ Just "world"
--   fromList [(1,"world")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.empty &amp; at 0 .~ Just "hello"
--   fromList [(0,"hello")]
--   </pre>
--   
--   We can traverse, fold over, and map over key-value pairs in a
--   <a>Map</a>, thanks to indexed traversals, folds and setters.
--   
--   <pre>
--   &gt;&gt;&gt; iover imapped const $ Map.fromList [(1, "Venus")]
--   fromList [(1,1)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ifoldMapOf ifolded (\i _ -&gt; Sum i) $ Map.fromList [(2, "Earth"), (3, "Mars")]
--   Sum {getSum = 5}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; itraverseOf_ ifolded (curry print) $ Map.fromList [(4, "Jupiter")]
--   (4,"Jupiter")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; itoListOf ifolded $ Map.fromList [(5, "Saturn")]
--   [(5,"Saturn")]
--   </pre>
--   
--   A related class, <a>Ixed</a>, allows us to use <a>ix</a> to traverse a
--   value at a particular key.
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [(2, "Earth")] &amp; ix 2 %~ ("New " ++)
--   fromList [(2,"New Earth")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; preview (ix 8) Map.empty
--   Nothing
--   </pre>
module Data.Map.Optics

-- | Construct a map from an <a>IxFold</a>.
--   
--   The construction is left-biased (see <a>union</a>), i.e. the first
--   occurences of keys in the fold or traversal order are preferred.
--   
--   <pre>
--   &gt;&gt;&gt; toMapOf ifolded ["hello", "world"]
--   fromList [(0,"hello"),(1,"world")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toMapOf (folded % ifolded) [('a',"alpha"),('b', "beta")]
--   fromList [('a',"alpha"),('b',"beta")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toMapOf (ifolded &lt;%&gt; ifolded) ["foo", "bar"]
--   fromList [((0,0),'f'),((0,1),'o'),((0,2),'o'),((1,0),'b'),((1,1),'a'),((1,2),'r')]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toMapOf (folded % ifolded) [('a', "hello"), ('b', "world"), ('a', "dummy")]
--   fromList [('a',"hello"),('b',"world")]
--   </pre>
toMapOf :: (Is k A_Fold, is `HasSingleIndex` i, Ord i) => Optic' k is s a -> s -> Map i a

-- | Focus on the largest key smaller than the given one and its
--   corresponding value.
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [('a', "hi"), ('b', "there")] &amp; over (lt 'b') (++ "!")
--   fromList [('a',"hi!"),('b',"there")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ipreview (lt 'a') $ Map.fromList [('a', 'x'), ('b', 'y')]
--   Nothing
--   </pre>
lt :: Ord k => k -> IxAffineTraversal' k (Map k v) v

-- | Focus on the smallest key greater than the given one and its
--   corresponding value.
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [('a', "hi"), ('b', "there")] &amp; over (gt 'b') (++ "!")
--   fromList [('a',"hi"),('b',"there")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ipreview (gt 'a') $ Map.fromList [('a', 'x'), ('b', 'y')]
--   Just ('b','y')
--   </pre>
gt :: Ord k => k -> IxAffineTraversal' k (Map k v) v

-- | Focus on the largest key smaller or equal than the given one and its
--   corresponding value.
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [('a', "hi"), ('b', "there")] &amp; over (le 'b') (++ "!")
--   fromList [('a',"hi"),('b',"there!")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ipreview (le 'a') $ Map.fromList [('a', 'x'), ('b', 'y')]
--   Just ('a','x')
--   </pre>
le :: Ord k => k -> IxAffineTraversal' k (Map k v) v

-- | Focus on the smallest key greater or equal than the given one and its
--   corresponding value.
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [('a', "hi"), ('c', "there")] &amp; over (ge 'b') (++ "!")
--   fromList [('a',"hi"),('c',"there!")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ipreview (ge 'b') $ Map.fromList [('a', 'x'), ('c', 'y')]
--   Just ('c','y')
--   </pre>
ge :: Ord k => k -> IxAffineTraversal' k (Map k v) v


-- | <a>IntMap</a> is an instance of <a>At</a> and provides <a>at</a> as a
--   lens on values at keys:
--   
--   <pre>
--   &gt;&gt;&gt; IntMap.fromList [(1, "world")] ^. at 1
--   Just "world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; IntMap.empty &amp; at 1 .~ Just "world"
--   fromList [(1,"world")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; IntMap.empty &amp; at 0 .~ Just "hello"
--   fromList [(0,"hello")]
--   </pre>
--   
--   We can traverse, fold over, and map over key-value pairs in an
--   <a>IntMap</a>, thanks to indexed traversals, folds and setters.
--   
--   <pre>
--   &gt;&gt;&gt; iover imapped const $ IntMap.fromList [(1, "Venus")]
--   fromList [(1,1)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ifoldMapOf ifolded (\i _ -&gt; Sum i) $ IntMap.fromList [(2, "Earth"), (3, "Mars")]
--   Sum {getSum = 5}
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; itraverseOf_ ifolded (curry print) $ IntMap.fromList [(4, "Jupiter")]
--   (4,"Jupiter")
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; itoListOf ifolded $ IntMap.fromList [(5, "Saturn")]
--   [(5,"Saturn")]
--   </pre>
--   
--   A related class, <a>Ixed</a>, allows us to use <a>ix</a> to traverse a
--   value at a particular key.
--   
--   <pre>
--   &gt;&gt;&gt; IntMap.fromList [(2, "Earth")] &amp; ix 2 %~ ("New " ++)
--   fromList [(2,"New Earth")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; preview (ix 8) IntMap.empty
--   Nothing
--   </pre>
module Data.IntMap.Optics

-- | Construct a map from an <a>IxFold</a>.
--   
--   The construction is left-biased (see <a>union</a>), i.e. the first
--   occurences of keys in the fold or traversal order are preferred.
--   
--   <pre>
--   &gt;&gt;&gt; toMapOf ifolded ["hello", "world"]
--   fromList [(0,"hello"),(1,"world")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toMapOf (folded % ifolded) [(1,"alpha"),(2, "beta")]
--   fromList [(1,"alpha"),(2,"beta")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toMapOf (icompose (\a b -&gt; 10*a+b) $ ifolded % ifolded) ["foo", "bar"]
--   fromList [(0,'f'),(1,'o'),(2,'o'),(10,'b'),(11,'a'),(12,'r')]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; toMapOf (folded % ifolded) [(1, "hello"), (2, "world"), (1, "dummy")]
--   fromList [(1,"hello"),(2,"world")]
--   </pre>
toMapOf :: (Is k A_Fold, is `HasSingleIndex` Int) => Optic' k is s a -> s -> IntMap a

-- | Focus on the largest key smaller than the given one and its
--   corresponding value.
--   
--   <pre>
--   &gt;&gt;&gt; IntMap.fromList [(1, "hi"), (2, "there")] &amp; over (lt 2) (++ "!")
--   fromList [(1,"hi!"),(2,"there")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ipreview (lt 1) $ IntMap.fromList [(1, 'x'), (2, 'y')]
--   Nothing
--   </pre>
lt :: Int -> IxAffineTraversal' Int (IntMap v) v

-- | Focus on the smallest key greater than the given one and its
--   corresponding value.
--   
--   <pre>
--   &gt;&gt;&gt; IntMap.fromList [(1, "hi"), (2, "there")] &amp; over (gt 2) (++ "!")
--   fromList [(1,"hi"),(2,"there")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ipreview (gt 1) $ IntMap.fromList [(1, 'x'), (2, 'y')]
--   Just (2,'y')
--   </pre>
gt :: Int -> IxAffineTraversal' Int (IntMap v) v

-- | Focus on the largest key smaller or equal than the given one and its
--   corresponding value.
--   
--   <pre>
--   &gt;&gt;&gt; IntMap.fromList [(1, "hi"), (2, "there")] &amp; over (le 2) (++ "!")
--   fromList [(1,"hi"),(2,"there!")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ipreview (le 1) $ IntMap.fromList [(1, 'x'), (2, 'y')]
--   Just (1,'x')
--   </pre>
le :: Int -> IxAffineTraversal' Int (IntMap v) v

-- | Focus on the smallest key greater or equal than the given one and its
--   corresponding value.
--   
--   <pre>
--   &gt;&gt;&gt; IntMap.fromList [(1, "hi"), (3, "there")] &amp; over (ge 2) (++ "!")
--   fromList [(1,"hi"),(3,"there!")]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ipreview (ge 2) $ IntMap.fromList [(1, 'x'), (3, 'y')]
--   Just (3,'y')
--   </pre>
ge :: Int -> IxAffineTraversal' Int (IntMap v) v


-- | A <a>Prism</a> generalises the notion of a constructor (just as a
--   <a>Lens</a> generalises the notion of a field).
module Optics.Prism

-- | Type synonym for a type-modifying prism.
type Prism s t a b = Optic A_Prism NoIx s t a b

-- | Type synonym for a type-preserving prism.
type Prism' s a = Optic' A_Prism NoIx s a

-- | Build a prism from a constructor and a matcher, which must respect the
--   well-formedness laws.
--   
--   If you want to build a <a>Prism</a> from the van Laarhoven
--   representation, use <tt>prismVL</tt> from the <tt>optics-vl</tt>
--   package.
prism :: (b -> t) -> (s -> Either t a) -> Prism s t a b

-- | This is usually used to build a <a>Prism'</a>, when you have to use an
--   operation like <a>cast</a> which already returns a <a>Maybe</a>.
prism' :: (b -> s) -> (s -> Maybe a) -> Prism s s a b

-- | This <a>Prism</a> compares for exact equality with a given value.
--   
--   <pre>
--   &gt;&gt;&gt; only 4 # ()
--   4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 5 ^? only 4
--   Nothing
--   </pre>
only :: Eq a => a -> Prism' a ()

-- | This <a>Prism</a> compares for approximate equality with a given value
--   and a predicate for testing, an example where the value is the empty
--   list and the predicate checks that a list is empty (same as
--   <a>_Empty</a> with the <a>AsEmpty</a> list instance):
--   
--   <pre>
--   &gt;&gt;&gt; nearly [] null # ()
--   []
--   
--   &gt;&gt;&gt; [1,2,3,4] ^? nearly [] null
--   Nothing
--   </pre>
--   
--   <pre>
--   <a>nearly</a> [] <a>null</a> :: <a>Prism'</a> [a] ()
--   </pre>
--   
--   To comply with the <a>Prism</a> laws the arguments you supply to
--   <tt>nearly a p</tt> are somewhat constrained.
--   
--   We assume <tt>p x</tt> holds iff <tt>x ≡ a</tt>. Under that assumption
--   then this is a valid <a>Prism</a>.
--   
--   This is useful when working with a type where you can test equality
--   for only a subset of its values, and the prism selects such a value.
nearly :: a -> (a -> Bool) -> Prism' a ()

-- | Work with a <a>Prism</a> as a constructor and a matcher.
withPrism :: Is k A_Prism => Optic k is s t a b -> ((b -> t) -> (s -> Either t a) -> r) -> r

-- | Use a <a>Prism</a> to work over part of a structure.
aside :: Is k A_Prism => Optic k is s t a b -> Prism (e, s) (e, t) (e, a) (e, b)

-- | Given a pair of prisms, project sums.
--   
--   Viewing a <a>Prism</a> as a co-<a>Lens</a>, this combinator can be
--   seen to be dual to <a>alongside</a>.
without :: (Is k A_Prism, Is l A_Prism) => Optic k is s t a b -> Optic l is u v c d -> Prism (Either s u) (Either t v) (Either a c) (Either b d)

-- | Lift a <a>Prism</a> through a <a>Traversable</a> functor, giving a
--   <a>Prism</a> that matches only if all the elements of the container
--   match the <a>Prism</a>.
below :: (Is k A_Prism, Traversable f) => Optic' k is s a -> Prism' (f s) (f a)

-- | Tag for a prism.
data A_Prism :: OpticKind


-- | This module defines <a>Prism</a>s for the constructors of the
--   <a>Maybe</a> datatype.
module Data.Maybe.Optics

-- | A <a>Prism</a> that matches on the <a>Nothing</a> constructor of
--   <a>Maybe</a>.
_Nothing :: Prism' (Maybe a) ()

-- | A <a>Prism</a> that matches on the <a>Just</a> constructor of
--   <a>Maybe</a>.
_Just :: Prism (Maybe a) (Maybe b) a b


-- | Additional optics for manipulating lists are present more generically
--   in this package.
--   
--   The <a>Ixed</a> class allows traversing the element at a specific list
--   index.
--   
--   <pre>
--   &gt;&gt;&gt; [0..10] ^? ix 4
--   Just 4
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0..5] &amp; ix 4 .~ 2
--   [0,1,2,3,2,5]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0..10] ^? ix 14
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0..5] &amp; ix 14 .~ 2
--   [0,1,2,3,4,5]
--   </pre>
--   
--   The <a>Cons</a> and <a>AsEmpty</a> classes provide <a>Prism</a>s for
--   list constructors.
--   
--   <pre>
--   &gt;&gt;&gt; [1..10] ^? _Cons
--   Just (1,[2,3,4,5,6,7,8,9,10])
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] ^? _Cons
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] ^? _Empty
--   Just ()
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _Cons # (1, _Empty # ()) :: [Int]
--   [1]
--   </pre>
--   
--   Additionally, <a>Snoc</a> provides a <a>Prism</a> for accessing the
--   end of a list. Note that this <a>Prism</a> always will need to
--   traverse the whole list.
--   
--   <pre>
--   &gt;&gt;&gt; [1..5] ^? _Snoc
--   Just ([1,2,3,4],5)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; _Snoc # ([1,2],5)
--   [1,2,5]
--   </pre>
--   
--   Finally, it's possible to traverse, fold over, and map over
--   index-value pairs thanks to instances of <a>TraversableWithIndex</a>,
--   <a>FoldableWithIndex</a>, and <a>FunctorWithIndex</a>.
--   
--   <pre>
--   &gt;&gt;&gt; imap (,) "Hello"
--   [(0,'H'),(1,'e'),(2,'l'),(3,'l'),(4,'o')]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ifoldMap replicate "Hello"
--   "ellllloooo"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; itraverse_ (curry print) "Hello"
--   (0,'H')
--   (1,'e')
--   (2,'l')
--   (3,'l')
--   (4,'o')
--   </pre>
module Data.List.Optics

-- | A <a>Prism</a> stripping a prefix from a list when used as a
--   <a>Traversal</a>, or prepending that prefix when run backwards:
--   
--   <pre>
--   &gt;&gt;&gt; "preview" ^? prefixed "pre"
--   Just "view"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "review" ^? prefixed "pre"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; prefixed "pre" # "amble"
--   "preamble"
--   </pre>
prefixed :: Eq a => [a] -> Prism' [a] [a]

-- | A <a>Prism</a> stripping a suffix from a list when used as a
--   <a>Traversal</a>, or appending that suffix when run backwards:
--   
--   <pre>
--   &gt;&gt;&gt; "review" ^? suffixed "view"
--   Just "re"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "review" ^? suffixed "tire"
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; suffixed ".o" # "hello"
--   "hello.o"
--   </pre>
suffixed :: Eq a => [a] -> Prism' [a] [a]


-- | This module defines <a>Prism</a>s for the constructors of the
--   <a>Either</a> datatype.
module Data.Either.Optics

-- | A <a>Prism</a> that matches on the <a>Left</a> constructor of
--   <a>Either</a>.
_Left :: Prism (Either a b) (Either c b) a c

-- | A <a>Prism</a> that matches on the <a>Right</a> constructor of
--   <a>Either</a>.
_Right :: Prism (Either a b) (Either a c) b c


-- | Some optics can be reversed with <a>re</a>. This is mainly useful to
--   invert <a>Iso</a>s:
--   
--   <pre>
--   &gt;&gt;&gt; let _Identity = iso runIdentity Identity
--   
--   &gt;&gt;&gt; view (_1 % re _Identity) ('x', "yz")
--   Identity 'x'
--   </pre>
--   
--   Yet we can use a <a>Lens</a> as a <a>Review</a> too:
--   
--   <pre>
--   &gt;&gt;&gt; review (re _1) ('x', "yz")
--   'x'
--   </pre>
--   
--   In the following diagram, red arrows illustrate how <a>re</a>
--   transforms optics. The <a>ReversedLens</a> and <a>ReversedPrism</a>
--   optic kinds are backwards versions of <a>Lens</a> and <a>Prism</a>
--   respectively, and are present so that <tt><a>re</a> . <a>re</a></tt>
--   does not change the optic kind.
--   
module Optics.Re

-- | Class for optics that can be <a>re</a>versed.
class ReversibleOptic k where {
    
    -- | Injective type family that maps an optic kind to the optic kind
    --   produced by <a>re</a>versing it.
    --   
    --   <pre>
    --   <a>ReversedOptic</a> <a>An_Iso</a>            = <a>An_Iso</a>
    --   <a>ReversedOptic</a> <a>A_Prism</a>           = <a>A_ReversedPrism</a>
    --   <a>ReversedOptic</a> <a>A_ReversedPrism</a>   = <a>A_Prism</a>
    --   <a>ReversedOptic</a> <a>A_Lens</a>            = <a>A_ReversedLens</a>
    --   <a>ReversedOptic</a> <a>A_ReversedLens</a>    = <a>A_Lens</a>
    --   <a>ReversedOptic</a> <a>A_Getter</a>          = <a>A_Review</a>
    --   <a>ReversedOptic</a> <a>A_Review</a>          = <a>A_Getter</a>
    --   </pre>
    type family ReversedOptic k = r | r -> k;
}

-- | Reverses optics, turning around <a>Iso</a> into <a>Iso</a>,
--   <a>Prism</a> into <a>ReversedPrism</a> (and back), <a>Lens</a> into
--   <a>ReversedLens</a> (and back) and <a>Getter</a> into <a>Review</a>
--   (and back).
re :: (ReversibleOptic k, "re" `AcceptsEmptyIndices` is) => Optic k is s t a b -> Optic (ReversedOptic k) is b a t s
instance Data.Profunctor.Indexed.Profunctor p => Data.Profunctor.Indexed.Profunctor (Optics.Re.Re p s t)
instance Optics.Internal.Bi.Bicontravariant p => Optics.Internal.Bi.Bifunctor (Optics.Re.Re p s t)
instance Optics.Internal.Bi.Bifunctor p => Optics.Internal.Bi.Bicontravariant (Optics.Re.Re p s t)
instance Data.Profunctor.Indexed.Strong p => Data.Profunctor.Indexed.Costrong (Optics.Re.Re p s t)
instance Data.Profunctor.Indexed.Costrong p => Data.Profunctor.Indexed.Strong (Optics.Re.Re p s t)
instance Data.Profunctor.Indexed.Choice p => Data.Profunctor.Indexed.Cochoice (Optics.Re.Re p s t)
instance Data.Profunctor.Indexed.Cochoice p => Data.Profunctor.Indexed.Choice (Optics.Re.Re p s t)
instance Optics.Re.ReversibleOptic Optics.Internal.Optic.Types.An_Iso
instance Optics.Re.ReversibleOptic Optics.Internal.Optic.Types.A_Prism
instance Optics.Re.ReversibleOptic Optics.Internal.Optic.Types.A_ReversedPrism
instance Optics.Re.ReversibleOptic Optics.Internal.Optic.Types.A_Lens
instance Optics.Re.ReversibleOptic Optics.Internal.Optic.Types.A_ReversedLens
instance Optics.Re.ReversibleOptic Optics.Internal.Optic.Types.A_Getter
instance Optics.Re.ReversibleOptic Optics.Internal.Optic.Types.A_Review


-- | This module defines <a>getting</a>, which turns a read-write optic
--   into its read-only counterpart.
module Optics.ReadOnly

-- | Class for read-write optics that have their read-only counterparts.
class ToReadOnly k s t a b

-- | Turn read-write optic into its read-only counterpart (or leave
--   read-only optics as-is).
--   
--   This is useful when you have an <tt>optic :: <a>Optic</a> k is s t a
--   b</tt> of read-write kind <tt>k</tt> such that <tt>s</tt>, <tt>t</tt>,
--   <tt>a</tt>, <tt>b</tt> are rigid, there is no evidence that <tt>s ~
--   t</tt> and <tt>a ~ b</tt> and you want to pass <tt>optic</tt> to one
--   of the functions that accept read-only optic kinds.
--   
--   Example:
--   
--   <pre>
--   λ&gt; let fstIntToChar = _1 :: Lens (Int, r) (Char, r) Int Char
--   λ&gt; :t view fstIntToChar
--   
--   <a>interactive</a>:1:6: error:
--       • Couldn't match type ‘Char’ with ‘Int’
--         Expected type: Optic' A_Lens NoIx (Int, r) Int
--           Actual type: Lens (Int, r) (Char, r) Int Char
--       • In the first argument of ‘view’, namely ‘fstIntToChar’
--         In the expression: view fstIntToChar
--   λ&gt; :t view (getting fstIntToChar)
--   view (getting fstIntToChar) :: (Int, r) -&gt; Int
--   </pre>
getting :: ToReadOnly k s t a b => Optic k is s t a b -> Optic' (Join A_Getter k) is s a
instance Optics.ReadOnly.ToReadOnly Optics.Internal.Optic.Types.An_Iso s t a b
instance Optics.ReadOnly.ToReadOnly Optics.Internal.Optic.Types.A_Lens s t a b
instance Optics.ReadOnly.ToReadOnly Optics.Internal.Optic.Types.A_Prism s t a b
instance Optics.ReadOnly.ToReadOnly Optics.Internal.Optic.Types.An_AffineTraversal s t a b
instance Optics.ReadOnly.ToReadOnly Optics.Internal.Optic.Types.A_Traversal s t a b
instance Optics.ReadOnly.ToReadOnly Optics.Internal.Optic.Types.A_ReversedPrism s t a b
instance (s Data.Type.Equality.~ t, a Data.Type.Equality.~ b) => Optics.ReadOnly.ToReadOnly Optics.Internal.Optic.Types.A_Getter s t a b
instance (s Data.Type.Equality.~ t, a Data.Type.Equality.~ b) => Optics.ReadOnly.ToReadOnly Optics.Internal.Optic.Types.An_AffineFold s t a b
instance (s Data.Type.Equality.~ t, a Data.Type.Equality.~ b) => Optics.ReadOnly.ToReadOnly Optics.Internal.Optic.Types.A_Fold s t a b


-- | A <a>ReversedLens</a> is a backwards <a>Lens</a>, i.e. a
--   <tt><a>ReversedLens</a> s t a b</tt> is equivalent to a
--   <tt><a>Lens</a> b a t s</tt>. These are typically produced by calling
--   <a>re</a> on a <a>Lens</a>. They are distinguished from a
--   <a>Review</a> so that <tt><a>re</a> . <a>re</a></tt> on a <a>Lens</a>
--   returns a <a>Lens</a>.
module Optics.ReversedLens

-- | Type synonym for a type-modifying reversed lens.
type ReversedLens s t a b = Optic A_ReversedLens NoIx s t a b

-- | Type synonym for a type-preserving reversed lens.
type ReversedLens' t b = Optic' A_ReversedLens NoIx t b

-- | Tag for a reversed lens.
data A_ReversedLens :: OpticKind


-- | A <a>ReversedPrism</a> is a backwards <a>Prism</a>, i.e. a
--   <tt><a>ReversedPrism</a> s t a b</tt> is equivalent to a
--   <tt><a>Prism</a> b a t s</tt>. These are typically produced by calling
--   <a>re</a> on a <a>Prism</a>. They are distinguished from a
--   <a>Getter</a> so that <tt><a>re</a> . <a>re</a></tt> on a <a>Prism</a>
--   returns a <a>Prism</a>.
module Optics.ReversedPrism

-- | Type synonym for a type-modifying reversed prism.
type ReversedPrism s t a b = Optic A_ReversedPrism NoIx s t a b

-- | Type synonym for a type-preserving reversed prism.
type ReversedPrism' s a = Optic' A_ReversedPrism NoIx s a

-- | Tag for a reversed prism.
data A_ReversedPrism :: OpticKind


-- | A <a>Review</a> is a backwards <a>Getter</a>, i.e. a <tt><a>Review</a>
--   T B</tt> is just a function <tt>B -&gt; T</tt>.
module Optics.Review

-- | Type synonym for a review.
type Review t b = Optic' A_Review NoIx t b

-- | An analogue of <a>to</a> for reviews.
unto :: (b -> t) -> Review t b

-- | Retrieve the value targeted by a <a>Review</a>.
--   
--   <pre>
--   &gt;&gt;&gt; review _Left "hi"
--   Left "hi"
--   </pre>
review :: Is k A_Review => Optic' k is t b -> b -> t

-- | Tag for a review.
data A_Review :: OpticKind


-- | An <a>Iso</a>morphism expresses the fact that two types have the same
--   structure, and hence can be converted from one to the other in either
--   direction.
module Optics.Iso

-- | Type synonym for a type-modifying iso.
type Iso s t a b = Optic An_Iso NoIx s t a b

-- | Type synonym for a type-preserving iso.
type Iso' s a = Optic' An_Iso NoIx s a

-- | Build an iso from a pair of inverse functions.
--   
--   If you want to build an <a>Iso</a> from the van Laarhoven
--   representation, use <tt>isoVL</tt> from the <tt>optics-vl</tt>
--   package.
iso :: (s -> a) -> (b -> t) -> Iso s t a b

-- | Capture type constraints as an isomorphism.
--   
--   <i>Note:</i> This is the identity optic:
--   
--   <pre>
--   &gt;&gt;&gt; :t view equality
--   view equality :: a -&gt; a
--   </pre>
equality :: (s ~ a, t ~ b) => Iso s t a b

-- | Proof of reflexivity.
simple :: Iso' a a

-- | Data types that are representationally equal are isomorphic.
--   
--   <pre>
--   &gt;&gt;&gt; view coerced 'x' :: Identity Char
--   Identity 'x'
--   </pre>
coerced :: (Coercible s a, Coercible t b) => Iso s t a b

-- | Type-preserving version of <a>coerced</a> with type parameters
--   rearranged for TypeApplications.
--   
--   <pre>
--   &gt;&gt;&gt; newtype MkInt = MkInt Int deriving Show
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; over (coercedTo @Int) (*3) (MkInt 2)
--   MkInt 6
--   </pre>
coercedTo :: forall a s. Coercible s a => Iso' s a

-- | Special case of <a>coerced</a> for trivial newtype wrappers.
--   
--   <pre>
--   &gt;&gt;&gt; over (coerced1 @Identity) (++ "bar") (Identity "foo")
--   Identity "foobar"
--   </pre>
coerced1 :: forall f s a. (Coercible s (f s), Coercible a (f a)) => Iso (f s) (f a) s a

-- | If <tt>v</tt> is an element of a type <tt>a</tt>, and <tt>a'</tt> is
--   <tt>a</tt> sans the element <tt>v</tt>, then <tt><a>non</a> v</tt> is
--   an isomorphism from <tt><a>Maybe</a> a'</tt> to <tt>a</tt>.
--   
--   <pre>
--   <a>non</a> ≡ <a>non'</a> <a>.</a> <a>only</a>
--   </pre>
--   
--   Keep in mind this is only a real isomorphism if you treat the domain
--   as being <tt><a>Maybe</a> (a sans v)</tt>.
--   
--   This is practically quite useful when you want to have a <a>Map</a>
--   where all the entries should have non-zero values.
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [("hello",1)] &amp; at "hello" % non 0 %~ (+2)
--   fromList [("hello",3)]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [("hello",1)] &amp; at "hello" % non 0 %~ (subtract 1)
--   fromList []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [("hello",1)] ^. at "hello" % non 0
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [] ^. at "hello" % non 0
--   0
--   </pre>
--   
--   This combinator is also particularly useful when working with nested
--   maps.
--   
--   <i>e.g.</i> When you want to create the nested <a>Map</a> when it is
--   missing:
--   
--   <pre>
--   &gt;&gt;&gt; Map.empty &amp; at "hello" % non Map.empty % at "world" ?~ "!!!"
--   fromList [("hello",fromList [("world","!!!")])]
--   </pre>
--   
--   and when have deleting the last entry from the nested <a>Map</a> mean
--   that we should delete its entry from the surrounding one:
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [("hello", Map.fromList [("world","!!!")])] &amp; at "hello" % non Map.empty % at "world" .~ Nothing
--   fromList []
--   </pre>
--   
--   It can also be used in reverse to exclude a given value:
--   
--   <pre>
--   &gt;&gt;&gt; non 0 # rem 10 4
--   Just 2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; non 0 # rem 10 5
--   Nothing
--   </pre>
non :: Eq a => a -> Iso' (Maybe a) a

-- | <tt><a>non'</a> p</tt> generalizes <tt><a>non</a> (p # ())</tt> to
--   take any unit <a>Prism</a>
--   
--   This function generates an isomorphism between <tt><a>Maybe</a> (a |
--   <a>isn't</a> p a)</tt> and <tt>a</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; Map.singleton "hello" Map.empty &amp; at "hello" % non' _Empty % at "world" ?~ "!!!"
--   fromList [("hello",fromList [("world","!!!")])]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [("hello", Map.fromList [("world","!!!")])] &amp; at "hello" % non' _Empty % at "world" .~ Nothing
--   fromList []
--   </pre>
non' :: Prism' a () -> Iso' (Maybe a) a

-- | <tt><a>anon</a> a p</tt> generalizes <tt><a>non</a> a</tt> to take any
--   value and a predicate.
--   
--   <pre>
--   <a>anon</a> a ≡ <a>non'</a> <a>.</a> <a>nearly</a> a
--   </pre>
--   
--   This function assumes that <tt>p a</tt> holds <tt><a>True</a></tt> and
--   generates an isomorphism between <tt><a>Maybe</a> (a | <a>not</a> (p
--   a))</tt> and <tt>a</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; Map.empty &amp; at "hello" % anon Map.empty Map.null % at "world" ?~ "!!!"
--   fromList [("hello",fromList [("world","!!!")])]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.fromList [("hello", Map.fromList [("world","!!!")])] &amp; at "hello" % anon Map.empty Map.null % at "world" .~ Nothing
--   fromList []
--   </pre>
anon :: a -> (a -> Bool) -> Iso' (Maybe a) a

-- | The canonical isomorphism for currying and uncurrying a function.
--   
--   <pre>
--   <a>curried</a> = <a>iso</a> <a>curry</a> <a>uncurry</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view curried fst 3 4
--   3
--   </pre>
curried :: Iso ((a, b) -> c) ((d, e) -> f) (a -> b -> c) (d -> e -> f)

-- | The canonical isomorphism for uncurrying and currying a function.
--   
--   <pre>
--   <a>uncurried</a> = <a>iso</a> <a>uncurry</a> <a>curry</a>
--   </pre>
--   
--   <pre>
--   <a>uncurried</a> = <a>re</a> <a>curried</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (view uncurried (+)) (1,2)
--   3
--   </pre>
uncurried :: Iso (a -> b -> c) (d -> e -> f) ((a, b) -> c) ((d, e) -> f)

-- | The isomorphism for flipping a function.
--   
--   <pre>
--   &gt;&gt;&gt; (view flipped (,)) 1 2
--   (2,1)
--   </pre>
flipped :: Iso (a -> b -> c) (a' -> b' -> c') (b -> a -> c) (b' -> a' -> c')

-- | Given a function that is its own inverse, this gives you an <a>Iso</a>
--   using it in both directions.
--   
--   <pre>
--   <a>involuted</a> ≡ <a>join</a> <a>iso</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "live" ^. involuted reverse
--   "evil"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "live" &amp; involuted reverse %~ ('d':)
--   "lived"
--   </pre>
involuted :: (a -> a) -> Iso' a a

-- | This class provides for symmetric bifunctors.
class Bifunctor p => Swapped p

-- | <pre>
--   <a>swapped</a> <a>.</a> <a>swapped</a> ≡ <a>id</a>
--   <a>first</a> f <a>.</a> <a>swapped</a> = <a>swapped</a> <a>.</a> <a>second</a> f
--   <a>second</a> g <a>.</a> <a>swapped</a> = <a>swapped</a> <a>.</a> <a>first</a> g
--   <a>bimap</a> f g <a>.</a> <a>swapped</a> = <a>swapped</a> <a>.</a> <a>bimap</a> g f
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view swapped (1,2)
--   (2,1)
--   </pre>
swapped :: Swapped p => Iso (p a b) (p c d) (p b a) (p d c)

-- | Extract the two components of an isomorphism.
withIso :: Iso s t a b -> ((s -> a) -> (b -> t) -> r) -> r

-- | Based on <tt>ala</tt> from Conor McBride's work on Epigram.
--   
--   This version is generalized to accept any <a>Iso</a>, not just a
--   <tt>newtype</tt>.
--   
--   <pre>
--   &gt;&gt;&gt; au (coerced1 @Sum) foldMap [1,2,3,4]
--   10
--   </pre>
--   
--   You may want to think of this combinator as having the following,
--   simpler type:
--   
--   <pre>
--   au :: <a>Iso</a> s t a b -&gt; ((b -&gt; t) -&gt; e -&gt; s) -&gt; e -&gt; a
--   </pre>
au :: Functor f => Iso s t a b -> ((b -> t) -> f s) -> f a

-- | The opposite of working <a>over</a> a <a>Setter</a> is working
--   <a>under</a> an isomorphism.
--   
--   <pre>
--   <a>under</a> ≡ <a>over</a> <a>.</a> <a>re</a>
--   </pre>
under :: Iso s t a b -> (t -> s) -> b -> a

-- | This can be used to lift any <a>Iso</a> into an arbitrary
--   <a>Functor</a>.
mapping :: (Functor f, Functor g) => Iso s t a b -> Iso (f s) (g t) (f a) (g b)

-- | Tag for an iso.
data An_Iso :: OpticKind
instance Optics.Iso.Swapped (,)
instance Optics.Iso.Swapped Data.Either.Either


-- | Note: <a>GHC.Generics</a> exports a number of names that collide with
--   <a>Optics</a> (at least <a>to</a>).
--   
--   You can use hiding or imports to mitigate this to an extent, and the
--   following imports, represent a fair compromise for user code:
--   
--   <pre>
--   import <a>Optics</a>
--   import <a>GHC.Generics</a> hiding (to)
--   import <a>GHC.Generics.Optics</a>
--   </pre>
--   
--   You can use <a>generic</a> to replace <a>from</a> and <a>to</a> from
--   <a>GHC.Generics</a>.
module GHC.Generics.Optics

-- | Convert from the data type to its representation (or back)
--   
--   <pre>
--   &gt;&gt;&gt; view (generic % re generic) "hello" :: String
--   "hello"
--   </pre>
generic :: (Generic a, Generic b) => Iso a b (Rep a c) (Rep b c)

-- | Convert from the data type to its representation (or back)
generic1 :: (Generic1 f, Generic1 g) => Iso (f a) (g b) (Rep1 f a) (Rep1 g b)
_V1 :: Lens (V1 s) (V1 t) a b
_U1 :: Iso (U1 p) (U1 q) () ()
_Par1 :: Iso (Par1 p) (Par1 q) p q
_Rec1 :: Iso (Rec1 f p) (Rec1 g q) (f p) (g q)
_K1 :: Iso (K1 i c p) (K1 j d q) c d
_M1 :: Iso (M1 i c f p) (M1 j d g q) (f p) (g q)
_L1 :: Prism ((a :+: c) t) ((b :+: c) t) (a t) (b t)
_R1 :: Prism ((c :+: a) t) ((c :+: b) t) (a t) (b t)


-- | This module defines <a>Lens</a>es for the fields of tuple types. These
--   are overloaded using the <a>Field1</a> to <a>Field9</a> typeclasses,
--   so that <a>_1</a> can be used as a <a>Lens</a> for the first field of
--   a tuple with any number of fields (up to the maximum supported tuple
--   size, which is currently 9). For example:
--   
--   <pre>
--   &gt;&gt;&gt; view _1 ('a','b','c')
--   'a'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; set _3 True ('a','b','c')
--   ('a','b',True)
--   </pre>
--   
--   If a single-constructor datatype has a <a>Generic</a> instance, the
--   corresponding <tt>FieldN</tt> instances can be defined using their
--   default methods:
--   
--   <pre>
--   &gt;&gt;&gt; :set -XDeriveGeneric
--   
--   &gt;&gt;&gt; data T a = MkT Int a deriving (Generic, Show)
--   
--   &gt;&gt;&gt; instance Field1 (T a) (T a) Int Int
--   
--   &gt;&gt;&gt; instance Field2 (T a) (T b) a b
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; set _2 'x' (MkT 1 False)
--   MkT 1 'x'
--   </pre>
module Data.Tuple.Optics

-- | Provides access to 1st field of a tuple.
class Field1 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 1st field of a tuple (and possibly change its type).
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) ^. _1
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) &amp; _1 .~ "hello"
--   ("hello",2)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverseOf _1 putStrLn ("hello","world")
--   hello
--   ((),"world")
--   </pre>
--   
--   This can also be used on larger tuples as well:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2,3,4,5) &amp; _1 %~ (+41)
--   (42,2,3,4,5)
--   </pre>
_1 :: Field1 s t a b => Lens s t a b

-- | Access the 1st field of a tuple (and possibly change its type).
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) ^. _1
--   1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,2) &amp; _1 .~ "hello"
--   ("hello",2)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverseOf _1 putStrLn ("hello","world")
--   hello
--   ((),"world")
--   </pre>
--   
--   This can also be used on larger tuples as well:
--   
--   <pre>
--   &gt;&gt;&gt; (1,2,3,4,5) &amp; _1 %~ (+41)
--   (42,2,3,4,5)
--   </pre>
_1 :: (Field1 s t a b, Generic s, Generic t, GIxed N0 (Rep s) (Rep t) a b) => Lens s t a b

-- | Provides access to the 2nd field of a tuple.
class Field2 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 2nd field of a tuple.
--   
--   <pre>
--   &gt;&gt;&gt; _2 .~ "hello" $ (1,(),3,4)
--   (1,"hello",3,4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,2,3,4) &amp; _2 %~ (*3)
--   (1,6,3,4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverseOf _2 print (1,2)
--   2
--   (1,())
--   </pre>
_2 :: Field2 s t a b => Lens s t a b

-- | Access the 2nd field of a tuple.
--   
--   <pre>
--   &gt;&gt;&gt; _2 .~ "hello" $ (1,(),3,4)
--   (1,"hello",3,4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (1,2,3,4) &amp; _2 %~ (*3)
--   (1,6,3,4)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; traverseOf _2 print (1,2)
--   2
--   (1,())
--   </pre>
_2 :: (Field2 s t a b, Generic s, Generic t, GIxed N1 (Rep s) (Rep t) a b) => Lens s t a b

-- | Provides access to the 3rd field of a tuple.
class Field3 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 3rd field of a tuple.
_3 :: Field3 s t a b => Lens s t a b

-- | Access the 3rd field of a tuple.
_3 :: (Field3 s t a b, Generic s, Generic t, GIxed N2 (Rep s) (Rep t) a b) => Lens s t a b

-- | Provide access to the 4th field of a tuple.
class Field4 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 4th field of a tuple.
_4 :: Field4 s t a b => Lens s t a b

-- | Access the 4th field of a tuple.
_4 :: (Field4 s t a b, Generic s, Generic t, GIxed N3 (Rep s) (Rep t) a b) => Lens s t a b

-- | Provides access to the 5th field of a tuple.
class Field5 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 5th field of a tuple.
_5 :: Field5 s t a b => Lens s t a b

-- | Access the 5th field of a tuple.
_5 :: (Field5 s t a b, Generic s, Generic t, GIxed N4 (Rep s) (Rep t) a b) => Lens s t a b

-- | Provides access to the 6th element of a tuple.
class Field6 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 6th field of a tuple.
_6 :: Field6 s t a b => Lens s t a b

-- | Access the 6th field of a tuple.
_6 :: (Field6 s t a b, Generic s, Generic t, GIxed N5 (Rep s) (Rep t) a b) => Lens s t a b

-- | Provide access to the 7th field of a tuple.
class Field7 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 7th field of a tuple.
_7 :: Field7 s t a b => Lens s t a b

-- | Access the 7th field of a tuple.
_7 :: (Field7 s t a b, Generic s, Generic t, GIxed N6 (Rep s) (Rep t) a b) => Lens s t a b

-- | Provide access to the 8th field of a tuple.
class Field8 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 8th field of a tuple.
_8 :: Field8 s t a b => Lens s t a b

-- | Access the 8th field of a tuple.
_8 :: (Field8 s t a b, Generic s, Generic t, GIxed N7 (Rep s) (Rep t) a b) => Lens s t a b

-- | Provides access to the 9th field of a tuple.
class Field9 s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | Access the 9th field of a tuple.
_9 :: Field9 s t a b => Lens s t a b

-- | Access the 9th field of a tuple.
_9 :: (Field9 s t a b, Generic s, Generic t, GIxed N8 (Rep s) (Rep t) a b) => Lens s t a b

-- | Strict version of <a>_1</a>
_1' :: Field1 s t a b => Lens s t a b

-- | Strict version of <a>_2</a>
_2' :: Field2 s t a b => Lens s t a b

-- | Strict version of <a>_3</a>
_3' :: Field3 s t a b => Lens s t a b

-- | Strict version of <a>_4</a>
_4' :: Field4 s t a b => Lens s t a b

-- | Strict version of <a>_5</a>
_5' :: Field5 s t a b => Lens s t a b

-- | Strict version of <a>_6</a>
_6' :: Field6 s t a b => Lens s t a b

-- | Strict version of <a>_7</a>
_7' :: Field7 s t a b => Lens s t a b

-- | Strict version of <a>_8</a>
_8' :: Field8 s t a b => Lens s t a b

-- | Strict version of <a>_9</a>
_9' :: Field9 s t a b => Lens s t a b
instance Data.Tuple.Optics.Field9 (a, b, c, d, e, f, g, h, i) (a, b, c, d, e, f, g, h, i') i i'
instance Data.Tuple.Optics.Field8 (a, b, c, d, e, f, g, h) (a, b, c, d, e, f, g, h') h h'
instance Data.Tuple.Optics.Field8 (a, b, c, d, e, f, g, h, i) (a, b, c, d, e, f, g, h', i) h h'
instance Data.Tuple.Optics.Field7 (a, b, c, d, e, f, g) (a, b, c, d, e, f, g') g g'
instance Data.Tuple.Optics.Field7 (a, b, c, d, e, f, g, h) (a, b, c, d, e, f, g', h) g g'
instance Data.Tuple.Optics.Field7 (a, b, c, d, e, f, g, h, i) (a, b, c, d, e, f, g', h, i) g g'
instance Data.Tuple.Optics.Field6 (a, b, c, d, e, f) (a, b, c, d, e, f') f f'
instance Data.Tuple.Optics.Field6 (a, b, c, d, e, f, g) (a, b, c, d, e, f', g) f f'
instance Data.Tuple.Optics.Field6 (a, b, c, d, e, f, g, h) (a, b, c, d, e, f', g, h) f f'
instance Data.Tuple.Optics.Field6 (a, b, c, d, e, f, g, h, i) (a, b, c, d, e, f', g, h, i) f f'
instance Data.Tuple.Optics.Field5 (a, b, c, d, e) (a, b, c, d, e') e e'
instance Data.Tuple.Optics.Field5 (a, b, c, d, e, f) (a, b, c, d, e', f) e e'
instance Data.Tuple.Optics.Field5 (a, b, c, d, e, f, g) (a, b, c, d, e', f, g) e e'
instance Data.Tuple.Optics.Field5 (a, b, c, d, e, f, g, h) (a, b, c, d, e', f, g, h) e e'
instance Data.Tuple.Optics.Field5 (a, b, c, d, e, f, g, h, i) (a, b, c, d, e', f, g, h, i) e e'
instance Data.Tuple.Optics.Field4 (a, b, c, d) (a, b, c, d') d d'
instance Data.Tuple.Optics.Field4 (a, b, c, d, e) (a, b, c, d', e) d d'
instance Data.Tuple.Optics.Field4 (a, b, c, d, e, f) (a, b, c, d', e, f) d d'
instance Data.Tuple.Optics.Field4 (a, b, c, d, e, f, g) (a, b, c, d', e, f, g) d d'
instance Data.Tuple.Optics.Field4 (a, b, c, d, e, f, g, h) (a, b, c, d', e, f, g, h) d d'
instance Data.Tuple.Optics.Field4 (a, b, c, d, e, f, g, h, i) (a, b, c, d', e, f, g, h, i) d d'
instance Data.Tuple.Optics.Field3 (a, b, c) (a, b, c') c c'
instance Data.Tuple.Optics.Field3 (a, b, c, d) (a, b, c', d) c c'
instance Data.Tuple.Optics.Field3 (a, b, c, d, e) (a, b, c', d, e) c c'
instance Data.Tuple.Optics.Field3 (a, b, c, d, e, f) (a, b, c', d, e, f) c c'
instance Data.Tuple.Optics.Field3 (a, b, c, d, e, f, g) (a, b, c', d, e, f, g) c c'
instance Data.Tuple.Optics.Field3 (a, b, c, d, e, f, g, h) (a, b, c', d, e, f, g, h) c c'
instance Data.Tuple.Optics.Field3 (a, b, c, d, e, f, g, h, i) (a, b, c', d, e, f, g, h, i) c c'
instance Data.Tuple.Optics.Field2 (Data.Functor.Product.Product f g a) (Data.Functor.Product.Product f g' a) (g a) (g' a)
instance Data.Tuple.Optics.Field2 ((GHC.Generics.:*:) f g p) ((GHC.Generics.:*:) f g' p) (g p) (g' p)
instance Data.Tuple.Optics.Field2 (a, b) (a, b') b b'
instance Data.Tuple.Optics.Field2 (a, b, c) (a, b', c) b b'
instance Data.Tuple.Optics.Field2 (a, b, c, d) (a, b', c, d) b b'
instance Data.Tuple.Optics.Field2 (a, b, c, d, e) (a, b', c, d, e) b b'
instance Data.Tuple.Optics.Field2 (a, b, c, d, e, f) (a, b', c, d, e, f) b b'
instance Data.Tuple.Optics.Field2 (a, b, c, d, e, f, g) (a, b', c, d, e, f, g) b b'
instance Data.Tuple.Optics.Field2 (a, b, c, d, e, f, g, h) (a, b', c, d, e, f, g, h) b b'
instance Data.Tuple.Optics.Field2 (a, b, c, d, e, f, g, h, i) (a, b', c, d, e, f, g, h, i) b b'
instance (Data.Tuple.Optics.GT (Data.Tuple.Optics.GSize s) n Data.Type.Equality.~ Data.Tuple.Optics.F, n' Data.Type.Equality.~ Data.Tuple.Optics.Subtract (Data.Tuple.Optics.GSize s) n, Data.Tuple.Optics.GIxed n' s' t' a b) => Data.Tuple.Optics.GIxed' Data.Tuple.Optics.F n s s' s t' a b
instance Data.Tuple.Optics.Field1 (Data.Functor.Identity.Identity a) (Data.Functor.Identity.Identity b) a b
instance Data.Tuple.Optics.Field1 (Data.Functor.Product.Product f g a) (Data.Functor.Product.Product f' g a) (f a) (f' a)
instance Data.Tuple.Optics.Field1 ((GHC.Generics.:*:) f g p) ((GHC.Generics.:*:) f' g p) (f p) (f' p)
instance Data.Tuple.Optics.Field1 (a, b) (a', b) a a'
instance Data.Tuple.Optics.Field1 (a, b, c) (a', b, c) a a'
instance Data.Tuple.Optics.Field1 (a, b, c, d) (a', b, c, d) a a'
instance Data.Tuple.Optics.Field1 (a, b, c, d, e) (a', b, c, d, e) a a'
instance Data.Tuple.Optics.Field1 (a, b, c, d, e, f) (a', b, c, d, e, f) a a'
instance Data.Tuple.Optics.Field1 (a, b, c, d, e, f, g) (a', b, c, d, e, f, g) a a'
instance Data.Tuple.Optics.Field1 (a, b, c, d, e, f, g, h) (a', b, c, d, e, f, g, h) a a'
instance Data.Tuple.Optics.Field1 (a, b, c, d, e, f, g, h, i) (a', b, c, d, e, f, g, h, i) a a'
instance (Data.Tuple.Optics.GT (Data.Tuple.Optics.GSize s) n Data.Type.Equality.~ Data.Tuple.Optics.T, Data.Tuple.Optics.GT (Data.Tuple.Optics.GSize t) n Data.Type.Equality.~ Data.Tuple.Optics.T, Data.Tuple.Optics.GIxed n s t a b) => Data.Tuple.Optics.GIxed' Data.Tuple.Optics.T n s s' t s' a b
instance Data.Tuple.Optics.GIxed Data.Tuple.Optics.N0 (GHC.Generics.K1 i a) (GHC.Generics.K1 i b) a b
instance (p Data.Type.Equality.~ Data.Tuple.Optics.GT (Data.Tuple.Optics.GSize s) n, p Data.Type.Equality.~ Data.Tuple.Optics.GT (Data.Tuple.Optics.GSize t) n, Data.Tuple.Optics.GIxed' p n s s' t t' a b) => Data.Tuple.Optics.GIxed n (s GHC.Generics.:*: s') (t GHC.Generics.:*: t') a b
instance Data.Tuple.Optics.GIxed n s t a b => Data.Tuple.Optics.GIxed n (GHC.Generics.M1 i c s) (GHC.Generics.M1 i c t) a b


-- | This module defines the <a>AsEmpty</a> class, which provides a
--   <a>Prism</a> for a type that may be <a>_Empty</a>.
--   
--   Note that orphan instances for this class are defined in the
--   <tt>Optics.Empty</tt> module from <tt>optics-extra</tt>, so if you are
--   not simply depending on <tt>optics</tt> you may wish to import that
--   module instead.
--   
--   <pre>
--   &gt;&gt;&gt; isn't _Empty [1,2,3]
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; case Nothing of { Empty -&gt; True; _ -&gt; False }
--   True
--   </pre>
module Optics.Empty.Core

-- | Class for types that may be <a>_Empty</a>.
class AsEmpty a

-- | <pre>
--   &gt;&gt;&gt; isn't _Empty [1,2,3]
--   True
--   </pre>
_Empty :: AsEmpty a => Prism' a ()

-- | <pre>
--   &gt;&gt;&gt; isn't _Empty [1,2,3]
--   True
--   </pre>
_Empty :: (AsEmpty a, Monoid a, Eq a) => Prism' a ()

-- | Pattern synonym for matching on any type with an <a>AsEmpty</a>
--   instance.
--   
--   <pre>
--   &gt;&gt;&gt; case Nothing of { Empty -&gt; True; _ -&gt; False }
--   True
--   </pre>
pattern Empty :: forall a. AsEmpty a => a
instance Optics.Empty.Core.AsEmpty GHC.Types.Ordering
instance Optics.Empty.Core.AsEmpty ()
instance Optics.Empty.Core.AsEmpty Data.Semigroup.Internal.Any
instance Optics.Empty.Core.AsEmpty Data.Semigroup.Internal.All
instance Optics.Empty.Core.AsEmpty GHC.Event.Internal.Event
instance (GHC.Classes.Eq a, GHC.Num.Num a) => Optics.Empty.Core.AsEmpty (Data.Semigroup.Internal.Product a)
instance (GHC.Classes.Eq a, GHC.Num.Num a) => Optics.Empty.Core.AsEmpty (Data.Semigroup.Internal.Sum a)
instance Optics.Empty.Core.AsEmpty (GHC.Maybe.Maybe a)
instance Optics.Empty.Core.AsEmpty (Data.Monoid.Last a)
instance Optics.Empty.Core.AsEmpty (Data.Monoid.First a)
instance Optics.Empty.Core.AsEmpty a => Optics.Empty.Core.AsEmpty (Data.Semigroup.Internal.Dual a)
instance (Optics.Empty.Core.AsEmpty a, Optics.Empty.Core.AsEmpty b) => Optics.Empty.Core.AsEmpty (a, b)
instance (Optics.Empty.Core.AsEmpty a, Optics.Empty.Core.AsEmpty b, Optics.Empty.Core.AsEmpty c) => Optics.Empty.Core.AsEmpty (a, b, c)
instance Optics.Empty.Core.AsEmpty [a]
instance Optics.Empty.Core.AsEmpty (Control.Applicative.ZipList a)
instance Optics.Empty.Core.AsEmpty (Data.Map.Internal.Map k a)
instance Optics.Empty.Core.AsEmpty (Data.IntMap.Internal.IntMap a)
instance Optics.Empty.Core.AsEmpty (Data.Set.Internal.Set a)
instance Optics.Empty.Core.AsEmpty Data.IntSet.Internal.IntSet
instance Optics.Empty.Core.AsEmpty (Data.Sequence.Internal.Seq a)


-- | This module defines the <a>Cons</a> and <a>Snoc</a> classes, which
--   provide <a>Prism</a>s for the leftmost and rightmost elements of a
--   container, respectively.
--   
--   Note that orphan instances for these classes are defined in the
--   <tt>Optics.Cons</tt> module from <tt>optics-extra</tt>, so if you are
--   not simply depending on <tt>optics</tt> you may wish to import that
--   module instead.
module Optics.Cons.Core

-- | This class provides a way to attach or detach elements on the left
--   side of a structure in a flexible manner.
class Cons s t a b | s -> a, t -> b, s b -> t, t a -> s

-- | <pre>
--   <a>_Cons</a> :: <a>Prism</a> [a] [b] (a, [a]) (b, [b])
--   <a>_Cons</a> :: <a>Prism</a> (<a>Seq</a> a) (<a>Seq</a> b) (a, <a>Seq</a> a) (b, <a>Seq</a> b)
--   <a>_Cons</a> :: <a>Prism</a> (Vector a) (Vector b) (a, Vector a) (b, Vector b)
--   <a>_Cons</a> :: <a>Prism'</a> <a>String</a> (<a>Char</a>, <a>String</a>)
--   <a>_Cons</a> :: <a>Prism'</a> Text (<a>Char</a>, Text)
--   <a>_Cons</a> :: <a>Prism'</a> ByteString (<a>Word8</a>, ByteString)
--   </pre>
_Cons :: Cons s t a b => Prism s t (a, s) (b, t)

-- | <a>cons</a> an element onto a container.
--   
--   This is an infix alias for <a>cons</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 1 &lt;| []
--   [1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 'a' &lt;| "bc"
--   "abc"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 &lt;| []
--   [1]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1 &lt;| [2, 3]
--   [1,2,3]
--   </pre>
(<|) :: Cons s s a a => a -> s -> s
infixr 5 <|

-- | <a>cons</a> an element onto a container.
--   
--   <pre>
--   &gt;&gt;&gt; cons 'a' ""
--   "a"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; cons 'a' "bc"
--   "abc"
--   </pre>
cons :: Cons s s a a => a -> s -> s
infixr 5 `cons`

-- | Attempt to extract the left-most element from a container, and a
--   version of the container without that element.
--   
--   <pre>
--   &gt;&gt;&gt; uncons []
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; uncons [1, 2, 3]
--   Just (1,[2,3])
--   </pre>
uncons :: Cons s s a a => s -> Maybe (a, s)

-- | An <a>AffineTraversal</a> reading and writing to the <a>head</a> of a
--   <i>non-empty</i> container.
--   
--   <pre>
--   &gt;&gt;&gt; "abc" ^? _head
--   Just 'a'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "abc" &amp; _head .~ 'd'
--   "dbc"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &amp; _head %~ (*10)
--   [10,2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; _head %~ absurd
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] ^? _head
--   Just 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] ^? _head
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2] ^? _head
--   Just 1
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; _head .~ 1
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0] &amp; _head .~ 2
--   [2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0,1] &amp; _head .~ 2
--   [2,1]
--   </pre>
_head :: Cons s s a a => AffineTraversal' s a

-- | An <a>AffineTraversal</a> reading and writing to the <a>tail</a> of a
--   <i>non-empty</i> container.
--   
--   <pre>
--   &gt;&gt;&gt; "ab" &amp; _tail .~ "cde"
--   "acde"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; _tail .~ [1,2]
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3,4,5] &amp; _tail % traversed %~ (*10)
--   [1,20,30,40,50]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2] &amp; _tail .~ [3,4,5]
--   [1,3,4,5]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; _tail .~ [1,2]
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "abc" ^? _tail
--   Just "bc"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "hello" ^? _tail
--   Just "ello"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "" ^? _tail
--   Nothing
--   </pre>
_tail :: Cons s s a a => AffineTraversal' s s

-- | Pattern synonym for matching on the leftmost element of a structure.
--   
--   <pre>
--   &gt;&gt;&gt; case ['a','b','c'] of (x :&lt; _) -&gt; x
--   'a'
--   </pre>
pattern (:<) :: forall s a. Cons s s a a => a -> s -> s
infixr 5 :<

-- | This class provides a way to attach or detach elements on the right
--   side of a structure in a flexible manner.
class Snoc s t a b | s -> a, t -> b, s b -> t, t a -> s
_Snoc :: Snoc s t a b => Prism s t (s, a) (t, b)

-- | <a>snoc</a> an element onto the end of a container.
--   
--   This is an infix alias for <a>snoc</a>.
--   
--   <pre>
--   &gt;&gt;&gt; "" |&gt; 'a'
--   "a"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "bc" |&gt; 'a'
--   "bca"
--   </pre>
(|>) :: Snoc s s a a => s -> a -> s
infixl 5 |>

-- | <a>snoc</a> an element onto the end of a container.
--   
--   <pre>
--   &gt;&gt;&gt; snoc "hello" '!'
--   "hello!"
--   </pre>
snoc :: Snoc s s a a => s -> a -> s
infixl 5 `snoc`

-- | Attempt to extract the right-most element from a container, and a
--   version of the container without that element.
--   
--   <pre>
--   &gt;&gt;&gt; unsnoc "hello!"
--   Just ("hello",'!')
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; unsnoc ""
--   Nothing
--   </pre>
unsnoc :: Snoc s s a a => s -> Maybe (s, a)

-- | An <a>AffineTraversal</a> reading and replacing all but the a last
--   element of a <i>non-empty</i> container.
--   
--   <pre>
--   &gt;&gt;&gt; "abcd" ^? _init
--   Just "abc"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "" ^? _init
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "ab" &amp; _init .~ "cde"
--   "cdeb"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; _init .~ [1,2]
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3,4] &amp; _init % traversed %~ (*10)
--   [10,20,30,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] ^? _init
--   Just [1,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "hello" ^? _init
--   Just "hell"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] ^? _init
--   Nothing
--   </pre>
_init :: Snoc s s a a => AffineTraversal' s s

-- | An <a>AffineTraversal</a> reading and writing to the last element of a
--   <i>non-empty</i> container.
--   
--   <pre>
--   &gt;&gt;&gt; "abc" ^? _last
--   Just 'c'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "" ^? _last
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3] &amp; _last %~ (+1)
--   [1,2,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1,2] ^? _last
--   Just 2
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] &amp; _last .~ 1
--   []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0] &amp; _last .~ 2
--   [2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [0,1] &amp; _last .~ 2
--   [0,2]
--   </pre>
_last :: Snoc s s a a => AffineTraversal' s a

-- | Pattern synonym for matching on the rightmost element of a structure.
--   
--   <pre>
--   &gt;&gt;&gt; case ['a','b','c'] of (_ :&gt; x) -&gt; x
--   'c'
--   </pre>
pattern (:>) :: forall s a. Snoc s s a a => s -> a -> s
infixl 5 :>
instance Optics.Cons.Core.Snoc [a] [b] a b
instance Optics.Cons.Core.Snoc (Control.Applicative.ZipList a) (Control.Applicative.ZipList b) a b
instance Optics.Cons.Core.Snoc (Data.Sequence.Internal.Seq a) (Data.Sequence.Internal.Seq b) a b
instance Optics.Cons.Core.Cons [a] [b] a b
instance Optics.Cons.Core.Cons (Control.Applicative.ZipList a) (Control.Applicative.ZipList b) a b
instance Optics.Cons.Core.Cons (Data.Sequence.Internal.Seq a) (Data.Sequence.Internal.Seq b) a b


-- | A <tt><a>Setter</a> S T A B</tt> has the ability to lift a function of
--   type <tt>A -&gt; B</tt> <a>over</a> a function of type <tt>S -&gt;
--   T</tt>, applying the function to update all the <tt>A</tt>s contained
--   in <tt>S</tt>. This can be used to <a>set</a> all the <tt>A</tt>s to a
--   single value (by lifting a constant function).
--   
--   This can be seen as a generalisation of <a>fmap</a>, where the type
--   <tt>S</tt> does not need to be a type constructor with <tt>A</tt> as
--   its last parameter.
module Optics.Setter

-- | Type synonym for a type-modifying setter.
type Setter s t a b = Optic A_Setter NoIx s t a b

-- | Type synonym for a type-preserving setter.
type Setter' s a = Optic' A_Setter NoIx s a

-- | Build a setter from a function to modify the element(s), which must
--   respect the well-formedness laws.
sets :: ((a -> b) -> s -> t) -> Setter s t a b

-- | Apply a setter as a modifier.
over :: Is k A_Setter => Optic k is s t a b -> (a -> b) -> s -> t

-- | Create a <a>Setter</a> for a <a>Functor</a>.
--   
--   <pre>
--   <a>over</a> <a>mapped</a> ≡ <a>fmap</a>
--   </pre>
mapped :: Functor f => Setter (f a) (f b) a b

-- | Apply a setter.
--   
--   <pre>
--   <a>set</a> o v ≡ <a>over</a> o (<a>const</a> v)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; set _1 'x' ('y', 'z')
--   ('x','z')
--   </pre>
set :: Is k A_Setter => Optic k is s t a b -> b -> s -> t

-- | Apply a setter, strictly.
--   
--   TODO DOC: what exactly is the strictness property?
set' :: Is k A_Setter => Optic k is s t a b -> b -> s -> t

-- | Apply a setter as a modifier, strictly.
--   
--   TODO DOC: what exactly is the strictness property?
--   
--   Example:
--   
--   <pre>
--   f :: Int -&gt; (Int, a) -&gt; (Int, a)
--   f k acc
--     | k &gt; 0     = f (k - 1) $ <a>over'</a> <a>_1</a> (+1) acc
--     | otherwise = acc
--   </pre>
--   
--   runs in constant space, but would result in a space leak if used with
--   <a>over</a>.
--   
--   Note that replacing <a>$</a> with <a>$!</a> or <a>_1</a> with
--   <a>_1'</a> (which amount to the same thing) doesn't help when
--   <a>over</a> is used, because the first coordinate of a pair is never
--   forced.
over' :: Is k A_Setter => Optic k is s t a b -> (a -> b) -> s -> t

-- | Tag for a setter.
data A_Setter :: OpticKind


-- | Defines some infix operators for optics operations. This is a
--   deliberately small collection.
--   
--   If you like operators, you may also wish to import
--   <tt>Optics.State.Operators</tt> from the <tt>optics-extra</tt>
--   package.
module Optics.Operators

-- | Flipped infix version of <a>view</a>.
(^.) :: Is k A_Getter => s -> Optic' k is s a -> a
infixl 8 ^.

-- | Flipped infix version of <a>toListOf</a>.
(^..) :: Is k A_Fold => s -> Optic' k is s a -> [a]
infixl 8 ^..

-- | Flipped infix version of <a>preview</a>.
(^?) :: Is k An_AffineFold => s -> Optic' k is s a -> Maybe a
infixl 8 ^?

-- | Flipped infix version of <a>review</a>.
(#) :: Is k A_Review => Optic' k is t b -> b -> t
infixr 8 #

-- | Infix version of <a>over</a>.
(%~) :: Is k A_Setter => Optic k is s t a b -> (a -> b) -> s -> t
infixr 4 %~

-- | Infix version of <a>over'</a>.
(%!~) :: Is k A_Setter => Optic k is s t a b -> (a -> b) -> s -> t
infixr 4 %!~

-- | Infix version of <a>set</a>.
(.~) :: Is k A_Setter => Optic k is s t a b -> b -> s -> t
infixr 4 .~

-- | Infix version of <a>set'</a>.
(!~) :: Is k A_Setter => Optic k is s t a b -> b -> s -> t
infixr 4 !~

-- | Set the target of a <a>Setter</a> to <a>Just</a> a value.
--   
--   <pre>
--   o <a>?~</a> b ≡ <a>set</a> o (<a>Just</a> b)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Nothing &amp; equality ?~ 'x'
--   Just 'x'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Map.empty &amp; at 3 ?~ 'x'
--   fromList [(3,'x')]
--   </pre>
(?~) :: Is k A_Setter => Optic k is s t a (Maybe b) -> b -> s -> t
infixr 4 ?~

-- | Strict version of (<a>?~</a>).
(?!~) :: Is k A_Setter => Optic k is s t a (Maybe b) -> b -> s -> t
infixr 4 ?!~


-- | This module provides optics for <a>Map</a> and <a>Set</a>-like
--   containers, including an <a>AffineTraversal</a> to traverse a key in a
--   map or an element of a sequence:
--   
--   <pre>
--   &gt;&gt;&gt; preview (ix 1) ['a','b','c']
--   Just 'b'
--   </pre>
--   
--   a <a>Lens</a> to get, set or delete a key in a map:
--   
--   <pre>
--   &gt;&gt;&gt; set (at 0) (Just 'b') (Map.fromList [(0, 'a')])
--   fromList [(0,'b')]
--   </pre>
--   
--   and a <a>Lens</a> to insert or remove an element of a set:
--   
--   <pre>
--   &gt;&gt;&gt; IntSet.fromList [1,2,3,4] &amp; contains 3 .~ False
--   fromList [1,2,4]
--   </pre>
--   
--   The <tt>Optics.At</tt> module from <tt>optics-extra</tt> provides
--   additional instances of the classes defined here.
module Optics.At.Core

-- | Type family that takes a key-value container type and returns the type
--   of keys (indices) into the container, for example <tt><a>Index</a>
--   (<a>Map</a> k a) ~ k</tt>. This is shared by <a>Ixed</a>, <a>At</a>
--   and <a>Contains</a>.
type family Index (s :: Type) :: Type

-- | Type family that takes a key-value container type and returns the type
--   of values stored in the container, for example <tt><a>IxValue</a>
--   (<a>Map</a> k a) ~ a</tt>. This is shared by both <a>Ixed</a> and
--   <a>At</a>.
type family IxValue (m :: Type) :: Type

-- | Provides a simple <a>AffineTraversal</a> lets you traverse the value
--   at a given key in a <a>Map</a> or element at an ordinal position in a
--   list or <a>Seq</a>.
class Ixed m where {
    
    -- | Type family that takes a key-value container type and returns the kind
    --   of optic to index into it. For most containers, it's
    --   <a>An_AffineTraversal</a>, <tt>Representable</tt> (Naperian)
    --   containers it is <a>A_Lens</a>, and multi-maps would have
    --   <tt>A_Traversal</tt>.
    type family IxKind (m :: Type) :: OpticKind;
    type IxKind m = An_AffineTraversal;
}

-- | <i>NB:</i> Setting the value of this <a>AffineTraversal</a> will only
--   set the value in <a>at</a> if it is already present.
--   
--   If you want to be able to insert <i>missing</i> values, you want
--   <a>at</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3,4] &amp; ix 2 %~ (*10)
--   [1,2,30,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "abcd" &amp; ix 2 .~ 'e'
--   "abed"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "abcd" ^? ix 2
--   Just 'c'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] ^? ix 2
--   Nothing
--   </pre>
ix :: Ixed m => Index m -> Optic' (IxKind m) NoIx m (IxValue m)

-- | <i>NB:</i> Setting the value of this <a>AffineTraversal</a> will only
--   set the value in <a>at</a> if it is already present.
--   
--   If you want to be able to insert <i>missing</i> values, you want
--   <a>at</a>.
--   
--   <pre>
--   &gt;&gt;&gt; [1,2,3,4] &amp; ix 2 %~ (*10)
--   [1,2,30,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "abcd" &amp; ix 2 .~ 'e'
--   "abed"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; "abcd" ^? ix 2
--   Just 'c'
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [] ^? ix 2
--   Nothing
--   </pre>
ix :: (Ixed m, At m, IxKind m ~ An_AffineTraversal) => Index m -> Optic' (IxKind m) NoIx m (IxValue m)

-- | A definition of <a>ix</a> for types with an <a>At</a> instance. This
--   is the default if you don't specify a definition for <a>ix</a>.
ixAt :: At m => Index m -> AffineTraversal' m (IxValue m)

-- | <a>At</a> provides a <a>Lens</a> that can be used to read, write or
--   delete the value associated with a key in a <a>Map</a>-like container
--   on an ad hoc basis.
--   
--   An instance of <a>At</a> should satisfy:
--   
--   <pre>
--   <a>ix</a> k ≡ <a>at</a> k <a>%</a> <a>_Just</a>
--   </pre>
class (Ixed m, IxKind m ~ An_AffineTraversal) => At m

-- | <pre>
--   &gt;&gt;&gt; Map.fromList [(1,"world")] ^. at 1
--   Just "world"
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; at 1 ?~ "hello" $ Map.empty
--   fromList [(1,"hello")]
--   </pre>
--   
--   <i>Note:</i> Usage of this function might introduce space leaks if
--   you're not careful to make sure that values put inside the <a>Just</a>
--   constructor are evaluated. To force the values and avoid such leaks,
--   use <a>at'</a> instead.
--   
--   <i>Note:</i> <a>Map</a>-like containers form a reasonable instance,
--   but not <a>Array</a>-like ones, where you cannot satisfy the
--   <a>Lens</a> laws.
at :: At m => Index m -> Lens' m (Maybe (IxValue m))

-- | Version of <a>at</a> strict in the value inside the <a>Just</a>
--   constructor.
--   
--   Example:
--   
--   <pre>
--   &gt;&gt;&gt; (at () .~ Just (error "oops") $ Nothing) `seq` ()
--   ()
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (at' () .~ Just (error "oops") $ Nothing) `seq` ()
--   *** Exception: oops
--   ...
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view (at ()) (Just $ error "oops") `seq` ()
--   ()
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; view (at' ()) (Just $ error "oops") `seq` ()
--   *** Exception: oops
--   ...
--   </pre>
--   
--   It also works as expected for other data structures:
--   
--   <pre>
--   &gt;&gt;&gt; (at 1 .~ Just (error "oops") $ Map.empty) `seq` ()
--   ()
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; (at' 1 .~ Just (error "oops") $ Map.empty) `seq` ()
--   *** Exception: oops
--   ...
--   </pre>
at' :: At m => Index m -> Lens' m (Maybe (IxValue m))

-- | Delete the value associated with a key in a <a>Map</a>-like container
--   
--   <pre>
--   <a>sans</a> k = <a>at</a> k <a>.~</a> Nothing
--   </pre>
sans :: At m => Index m -> m -> m

-- | This class provides a simple <a>Lens</a> that lets you view (and
--   modify) information about whether or not a container contains a given
--   <a>Index</a>. Instances are provided for <a>Set</a>-like containers
--   only.
class Contains m

-- | <pre>
--   &gt;&gt;&gt; IntSet.fromList [1,2,3,4] ^. contains 3
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; IntSet.fromList [1,2,3,4] ^. contains 5
--   False
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; IntSet.fromList [1,2,3,4] &amp; contains 3 .~ False
--   fromList [1,2,4]
--   </pre>
contains :: Contains m => Index m -> Lens' m Bool
instance GHC.Classes.Eq e => Optics.At.Core.Ixed (e -> a)
instance Optics.At.Core.Ixed (GHC.Maybe.Maybe a)
instance Optics.At.Core.Ixed [a]
instance Optics.At.Core.Ixed (GHC.Base.NonEmpty a)
instance Optics.At.Core.Ixed (Data.Functor.Identity.Identity a)
instance Optics.At.Core.Ixed (Data.Tree.Tree a)
instance Optics.At.Core.Ixed (Data.Sequence.Internal.Seq a)
instance Optics.At.Core.Ixed (Data.IntMap.Internal.IntMap a)
instance GHC.Classes.Ord k => Optics.At.Core.Ixed (Data.Map.Internal.Map k a)
instance GHC.Classes.Ord k => Optics.At.Core.Ixed (Data.Set.Internal.Set k)
instance Optics.At.Core.Ixed Data.IntSet.Internal.IntSet
instance GHC.Arr.Ix i => Optics.At.Core.Ixed (GHC.Arr.Array i e)
instance (Data.Array.Base.IArray Data.Array.Base.UArray e, GHC.Arr.Ix i) => Optics.At.Core.Ixed (Data.Array.Base.UArray i e)
instance (a0 Data.Type.Equality.~ a1) => Optics.At.Core.Ixed (a0, a1)
instance (a0 Data.Type.Equality.~ a1, a0 Data.Type.Equality.~ a2) => Optics.At.Core.Ixed (a0, a1, a2)
instance (a0 Data.Type.Equality.~ a1, a0 Data.Type.Equality.~ a2, a0 Data.Type.Equality.~ a3) => Optics.At.Core.Ixed (a0, a1, a2, a3)
instance (a0 Data.Type.Equality.~ a1, a0 Data.Type.Equality.~ a2, a0 Data.Type.Equality.~ a3, a0 Data.Type.Equality.~ a4) => Optics.At.Core.Ixed (a0, a1, a2, a3, a4)
instance (a0 Data.Type.Equality.~ a1, a0 Data.Type.Equality.~ a2, a0 Data.Type.Equality.~ a3, a0 Data.Type.Equality.~ a4, a0 Data.Type.Equality.~ a5) => Optics.At.Core.Ixed (a0, a1, a2, a3, a4, a5)
instance (a0 Data.Type.Equality.~ a1, a0 Data.Type.Equality.~ a2, a0 Data.Type.Equality.~ a3, a0 Data.Type.Equality.~ a4, a0 Data.Type.Equality.~ a5, a0 Data.Type.Equality.~ a6) => Optics.At.Core.Ixed (a0, a1, a2, a3, a4, a5, a6)
instance (a0 Data.Type.Equality.~ a1, a0 Data.Type.Equality.~ a2, a0 Data.Type.Equality.~ a3, a0 Data.Type.Equality.~ a4, a0 Data.Type.Equality.~ a5, a0 Data.Type.Equality.~ a6, a0 Data.Type.Equality.~ a7) => Optics.At.Core.Ixed (a0, a1, a2, a3, a4, a5, a6, a7)
instance (a0 Data.Type.Equality.~ a1, a0 Data.Type.Equality.~ a2, a0 Data.Type.Equality.~ a3, a0 Data.Type.Equality.~ a4, a0 Data.Type.Equality.~ a5, a0 Data.Type.Equality.~ a6, a0 Data.Type.Equality.~ a7, a0 Data.Type.Equality.~ a8) => Optics.At.Core.Ixed (a0, a1, a2, a3, a4, a5, a6, a7, a8)
instance Optics.At.Core.At (GHC.Maybe.Maybe a)
instance Optics.At.Core.At (Data.IntMap.Internal.IntMap a)
instance GHC.Classes.Ord k => Optics.At.Core.At (Data.Map.Internal.Map k a)
instance Optics.At.Core.At Data.IntSet.Internal.IntSet
instance GHC.Classes.Ord k => Optics.At.Core.At (Data.Set.Internal.Set k)
instance Optics.At.Core.Contains Data.IntSet.Internal.IntSet
instance GHC.Classes.Ord a => Optics.At.Core.Contains (Data.Set.Internal.Set a)


module Optics.Arrow
class Arrow arr => ArrowOptic k arr

-- | Turn an optic into an arrow transformer.
overA :: ArrowOptic k arr => Optic k is s t a b -> arr a b -> arr s t

-- | Run an arrow command and use the output to set all the targets of an
--   optic to the result.
--   
--   <pre>
--   runKleisli action ((), (), ()) where
--     action =      assignA _1 (Kleisli (const getVal1))
--              &gt;&gt;&gt; assignA _2 (Kleisli (const getVal2))
--              &gt;&gt;&gt; assignA _3 (Kleisli (const getVal3))
--     getVal1 :: Either String Int
--     getVal1 = ...
--     getVal2 :: Either String Bool
--     getVal2 = ...
--     getVal3 :: Either String Char
--     getVal3 = ...
--   </pre>
--   
--   has the type <tt><a>Either</a> <a>String</a> (<a>Int</a>, <a>Bool</a>,
--   <a>Char</a>)</tt>
assignA :: (Is k A_Setter, Arrow arr) => Optic k is s t a b -> arr s b -> arr s t
instance Control.Arrow.Arrow arr => Optics.Arrow.ArrowOptic Optics.Internal.Optic.Types.An_Iso arr
instance Control.Arrow.Arrow arr => Optics.Arrow.ArrowOptic Optics.Internal.Optic.Types.A_Lens arr
instance Control.Arrow.ArrowChoice arr => Optics.Arrow.ArrowOptic Optics.Internal.Optic.Types.A_Prism arr
instance Control.Arrow.ArrowChoice arr => Optics.Arrow.ArrowOptic Optics.Internal.Optic.Types.An_AffineTraversal arr
instance Control.Category.Category p => Control.Category.Category (Optics.Arrow.WrappedArrow p i)
instance Control.Arrow.Arrow p => Control.Arrow.Arrow (Optics.Arrow.WrappedArrow p i)
instance Control.Arrow.Arrow p => Data.Profunctor.Indexed.Profunctor (Optics.Arrow.WrappedArrow p)
instance Control.Arrow.Arrow p => Data.Profunctor.Indexed.Strong (Optics.Arrow.WrappedArrow p)
instance Control.Arrow.ArrowChoice p => Data.Profunctor.Indexed.Choice (Optics.Arrow.WrappedArrow p)
instance Control.Arrow.ArrowChoice p => Data.Profunctor.Indexed.Visiting (Optics.Arrow.WrappedArrow p)


module Numeric.Optics

-- | A prism that shows and reads integers in base-2 through base-36
--   
--   Note: This is an improper prism, since leading 0s are stripped when
--   reading.
--   
--   <pre>
--   &gt;&gt;&gt; "100" ^? base 16
--   Just 256
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; 1767707668033969 ^. re (base 36)
--   "helloworld"
--   </pre>
base :: (HasCallStack, Integral a) => Int -> Prism' String a

-- | This <a>Prism</a> can be used to model the fact that every
--   <a>Integral</a> type is a subset of <a>Integer</a>.
--   
--   Embedding through the <a>Prism</a> only succeeds if the <a>Integer</a>
--   would pass through unmodified when re-extracted.
integral :: (Integral a, Integral b) => Prism Integer Integer a b

-- | <pre>
--   <a>binary</a> = <a>base</a> 2
--   </pre>
binary :: Integral a => Prism' String a

-- | <pre>
--   <a>octal</a> = <a>base</a> 8
--   </pre>
octal :: Integral a => Prism' String a

-- | <pre>
--   <a>decimal</a> = <a>base</a> 10
--   </pre>
decimal :: Integral a => Prism' String a

-- | <pre>
--   <a>hex</a> = <a>base</a> 16
--   </pre>
hex :: Integral a => Prism' String a

-- | <pre>
--   <a>adding</a> n = <a>iso</a> (+n) (subtract n)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; [1..3] ^.. traversed % adding 1000
--   [1001,1002,1003]
--   </pre>
adding :: Num a => a -> Iso' a a

-- | <pre>
--   <a>subtracting</a> n = <a>iso</a> (subtract n) ((+n)
--   <a>subtracting</a> n = <a>re</a> (<a>adding</a> n)
--   </pre>
subtracting :: Num a => a -> Iso' a a

-- | <pre>
--   <a>multiplying</a> n = iso (*n) (/n)
--   </pre>
--   
--   Note: This errors for n = 0
--   
--   <pre>
--   &gt;&gt;&gt; 5 &amp; multiplying 1000 %~ (+3)
--   5.003
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; let fahrenheit = multiplying (9/5) % adding 32 in 230 ^. re fahrenheit
--   110.0
--   </pre>
multiplying :: (Fractional a, Eq a) => a -> Iso' a a

-- | <pre>
--   <a>dividing</a> n = <a>iso</a> (/n) (*n)
--   <a>dividing</a> n = <a>re</a> (<a>multiplying</a> n)
--   </pre>
--   
--   Note: This errors for n = 0
dividing :: (Fractional a, Eq a) => a -> Iso' a a

-- | <pre>
--   <a>exponentiating</a> n = <a>iso</a> (**n) (**recip n)
--   </pre>
--   
--   Note: This errors for n = 0
--   
--   <pre>
--   &gt;&gt;&gt; au (coerced1 @Sum % re (exponentiating 2)) (foldMapOf each) (3,4) == 5
--   True
--   </pre>
exponentiating :: (Floating a, Eq a) => a -> Iso' a a

-- | <pre>
--   <a>negated</a> = <a>iso</a> <a>negate</a> <a>negate</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; au (coerced1 @Sum % negated) (foldMapOf each) (3,4) == 7
--   True
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; au (coerced1 @Sum) (foldMapOf (each % negated)) (3,4) == -7
--   True
--   </pre>
negated :: Num a => Iso' a a

-- | Pattern synonym that can be used to construct or pattern match on an
--   <a>Integer</a> as if it were of any <a>Integral</a> type.
pattern Integral :: forall a. Integral a => a -> Integer


-- | This module defines optics for constructing and manipulating finite
--   <a>Set</a>s.
module Data.Set.Optics

-- | This <a>Setter</a> can be used to change the type of a <a>Set</a> by
--   mapping the elements to new values.
--   
--   Sadly, you can't create a valid <a>Traversal</a> for a <a>Set</a>, but
--   you can manipulate it by reading using <a>folded</a> and reindexing it
--   via <a>setmapped</a>.
--   
--   <pre>
--   &gt;&gt;&gt; over setmapped (+1) (fromList [1,2,3,4])
--   fromList [2,3,4,5]
--   </pre>
setmapped :: Ord b => Setter (Set a) (Set b) a b

-- | Construct a set from a fold.
--   
--   <pre>
--   &gt;&gt;&gt; setOf folded ["hello","world"]
--   fromList ["hello","world"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; setOf (folded % _2) [("hello",1),("world",2),("!!!",3)]
--   fromList [1,2,3]
--   </pre>
setOf :: (Is k A_Fold, Ord a) => Optic' k is s a -> s -> Set a


-- | This module defines optics for constructing and manipulating finite
--   <a>IntSet</a>s.
module Data.IntSet.Optics

-- | IntSet isn't Foldable, but this <a>Fold</a> can be used to access the
--   members of an <a>IntSet</a>.
--   
--   <pre>
--   &gt;&gt;&gt; sumOf members $ setOf folded [1,2,3,4]
--   10
--   </pre>
members :: Fold IntSet Int

-- | This <a>Setter</a> can be used to change the type of a <a>IntSet</a>
--   by mapping the elements to new values.
--   
--   Sadly, you can't create a valid <a>Traversal</a> for an <a>IntSet</a>,
--   but you can manipulate it by reading using <a>folded</a> and
--   reindexing it via <a>setmapped</a>.
--   
--   <pre>
--   &gt;&gt;&gt; over setmapped (+1) (fromList [1,2,3,4])
--   fromList [2,3,4,5]
--   </pre>
setmapped :: Setter' IntSet Int

-- | Construct an <a>IntSet</a> from a fold.
--   
--   <pre>
--   &gt;&gt;&gt; setOf folded [1,2,3,4]
--   fromList [1,2,3,4]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; setOf (folded % _2) [("hello",1),("world",2),("!!!",3)]
--   fromList [1,2,3]
--   </pre>
setOf :: Is k A_Fold => Optic' k is s Int -> s -> IntSet


-- | A <a>Traversal</a> lifts an effectful operation on elements to act on
--   structures containing those elements.
--   
--   That is, given a function <tt>op :: A -&gt; F B</tt> where <tt>F</tt>
--   is <a>Applicative</a>, a <tt><a>Traversal</a> S T A B</tt> can produce
--   a function <tt>S -&gt; F T</tt> that applies <tt>op</tt> to all the
--   <tt>A</tt>s contained in the <tt>S</tt>.
--   
--   This can be seen as a generalisation of <a>traverse</a>, where the
--   type <tt>S</tt> does not need to be a type constructor with <tt>A</tt>
--   as the last parameter.
--   
--   A <a>Lens</a> is a <a>Traversal</a> that acts on a single value.
--   
--   A close relative is the <a>AffineTraversal</a>, which is a
--   <a>Traversal</a> that acts on at most one value.
module Optics.Traversal

-- | Type synonym for a type-modifying traversal.
type Traversal s t a b = Optic A_Traversal NoIx s t a b

-- | Type synonym for a type-preserving traversal.
type Traversal' s a = Optic' A_Traversal NoIx s a

-- | Build a traversal from the van Laarhoven representation.
--   
--   <pre>
--   <a>traversalVL</a> <a>.</a> <a>traverseOf</a> ≡ <a>id</a>
--   <a>traverseOf</a> <a>.</a> <a>traversalVL</a> ≡ <a>id</a>
--   </pre>
traversalVL :: TraversalVL s t a b -> Traversal s t a b

-- | Map each element of a structure targeted by a <a>Traversal</a>,
--   evaluate these actions from left to right, and collect the results.
traverseOf :: (Is k A_Traversal, Applicative f) => Optic k is s t a b -> (a -> f b) -> s -> f t

-- | Construct a <a>Traversal</a> via the <a>Traversable</a> class.
--   
--   <pre>
--   <a>traverseOf</a> <a>traversed</a> = <a>traverse</a>
--   </pre>
traversed :: Traversable t => Traversal (t a) (t b) a b

-- | A version of <a>traverseOf</a> with the arguments flipped.
forOf :: (Is k A_Traversal, Applicative f) => Optic k is s t a b -> s -> (a -> f b) -> f t

-- | Evaluate each action in the structure from left to right, and collect
--   the results.
--   
--   <pre>
--   &gt;&gt;&gt; sequenceOf each ([1,2],[3,4])
--   [(1,3),(1,4),(2,3),(2,4)]
--   </pre>
--   
--   <pre>
--   <a>sequence</a> ≡ <a>sequenceOf</a> <a>traversed</a> ≡ <a>traverse</a> <a>id</a>
--   <a>sequenceOf</a> o ≡ <a>traverseOf</a> o <a>id</a>
--   </pre>
sequenceOf :: (Is k A_Traversal, Applicative f) => Optic k is s t (f b) b -> s -> f t

-- | This generalizes <a>transpose</a> to an arbitrary <a>Traversal</a>.
--   
--   Note: <a>transpose</a> handles ragged inputs more intelligently, but
--   for non-ragged inputs:
--   
--   <pre>
--   &gt;&gt;&gt; transposeOf traversed [[1,2,3],[4,5,6]]
--   [[1,4],[2,5],[3,6]]
--   </pre>
--   
--   <pre>
--   <a>transpose</a> ≡ <a>transposeOf</a> <a>traverse</a>
--   </pre>
transposeOf :: Is k A_Traversal => Optic k is s t [a] a -> s -> [t]

-- | This generalizes <a>mapAccumR</a> to an arbitrary <a>Traversal</a>.
--   
--   <pre>
--   <a>mapAccumR</a> ≡ <a>mapAccumROf</a> <a>traversed</a>
--   </pre>
--   
--   <a>mapAccumROf</a> accumulates <a>State</a> from right to left.
mapAccumROf :: Is k A_Traversal => Optic k is s t a b -> (acc -> a -> (b, acc)) -> acc -> s -> (t, acc)

-- | This generalizes <a>mapAccumL</a> to an arbitrary <a>Traversal</a>.
--   
--   <pre>
--   <a>mapAccumL</a> ≡ <a>mapAccumLOf</a> <a>traverse</a>
--   </pre>
--   
--   <a>mapAccumLOf</a> accumulates <a>State</a> from left to right.
mapAccumLOf :: Is k A_Traversal => Optic k is s t a b -> (acc -> a -> (b, acc)) -> acc -> s -> (t, acc)

-- | This permits the use of <a>scanr1</a> over an arbitrary
--   <a>Traversal</a>.
--   
--   <pre>
--   <a>scanr1</a> ≡ <a>scanr1Of</a> <a>traversed</a>
--   </pre>
scanr1Of :: Is k A_Traversal => Optic k is s t a a -> (a -> a -> a) -> s -> t

-- | This permits the use of <a>scanl1</a> over an arbitrary
--   <a>Traversal</a>.
--   
--   <pre>
--   <a>scanl1</a> ≡ <a>scanl1Of</a> <a>traversed</a>
--   </pre>
scanl1Of :: Is k A_Traversal => Optic k is s t a a -> (a -> a -> a) -> s -> t

-- | Try to map a function over this <a>Traversal</a>, returning Nothing if
--   the traversal has no targets.
--   
--   <pre>
--   &gt;&gt;&gt; failover (element 3) (*2) [1,2]
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; failover _Left (*2) (Right 4)
--   Nothing
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; failover _Right (*2) (Right 4)
--   Just (Right 8)
--   </pre>
failover :: Is k A_Traversal => Optic k is s t a b -> (a -> b) -> s -> Maybe t

-- | Version of <a>failover</a> strict in the application of <tt>f</tt>.
failover' :: Is k A_Traversal => Optic k is s t a b -> (a -> b) -> s -> Maybe t

-- | This allows you to <a>traverse</a> the elements of a traversal in the
--   opposite order.
backwards :: Is k A_Traversal => Optic k is s t a b -> Traversal s t a b

-- | <a>partsOf</a> turns a <a>Traversal</a> into a <a>Lens</a>.
--   
--   <i>Note:</i> You should really try to maintain the invariant of the
--   number of children in the list.
--   
--   <pre>
--   &gt;&gt;&gt; ('a','b','c') &amp; partsOf each .~ ['x','y','z']
--   ('x','y','z')
--   </pre>
--   
--   Any extras will be lost. If you do not supply enough, then the
--   remainder will come from the original structure.
--   
--   <pre>
--   &gt;&gt;&gt; ('a','b','c') &amp; partsOf each .~ ['w','x','y','z']
--   ('w','x','y')
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ('a','b','c') &amp; partsOf each .~ ['x','y']
--   ('x','y','c')
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; ('b', 'a', 'd', 'c') &amp; partsOf each %~ sort
--   ('a','b','c','d')
--   </pre>
--   
--   So technically, this is only a <a>Lens</a> if you do not change the
--   number of results it returns.
partsOf :: forall k is s t a. Is k A_Traversal => Optic k is s t a a -> Lens s t [a] [a]

-- | Tag for a traversal.
data A_Traversal :: OpticKind

-- | Type synonym for a type-modifying van Laarhoven traversal.
type TraversalVL s t a b = forall f. Applicative f => (a -> f b) -> s -> f t

-- | Type synonym for a type-preserving van Laarhoven traversal.
type TraversalVL' s a = TraversalVL s s a a


-- | An <a>IxTraversal</a> is an indexed version of a <a>Traversal</a>. See
--   the "Indexed optics" section of the overview documentation in the
--   <tt>Optics</tt> module of the main <tt>optics</tt> package for more
--   details on indexed optics.
module Optics.IxTraversal

-- | Type synonym for a type-modifying indexed traversal.
type IxTraversal i s t a b = Optic A_Traversal (WithIx i) s t a b

-- | Type synonym for a type-preserving indexed traversal.
type IxTraversal' i s a = Optic' A_Traversal (WithIx i) s a

-- | Build an indexed traversal from the van Laarhoven representation.
--   
--   <pre>
--   <a>itraversalVL</a> <a>.</a> <a>itraverseOf</a> ≡ <a>id</a>
--   <a>itraverseOf</a> <a>.</a> <a>itraversalVL</a> ≡ <a>id</a>
--   </pre>
itraversalVL :: IxTraversalVL i s t a b -> IxTraversal i s t a b

-- | Map each element of a structure targeted by an <a>IxTraversal</a>
--   (supplying the index), evaluate these actions from left to right, and
--   collect the results.
--   
--   This yields the van Laarhoven representation of an indexed traversal.
itraverseOf :: (Is k A_Traversal, Applicative f, is `HasSingleIndex` i) => Optic k is s t a b -> (i -> a -> f b) -> s -> f t

-- | Indexed traversal via the <a>TraversableWithIndex</a> class.
--   
--   <pre>
--   <a>itraverseOf</a> <a>itraversed</a> ≡ <a>itraverse</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iover (itraversed &lt;%&gt; itraversed) (,) ["ab", "cd"]
--   [[((0,0),'a'),((0,1),'b')],[((1,0),'c'),((1,1),'d')]]
--   </pre>
itraversed :: TraversableWithIndex i f => IxTraversal i (f a) (f b) a b

-- | This is the trivial empty <a>IxTraversal</a>.
--   
--   <pre>
--   &gt;&gt;&gt; 6 &amp; ignored %~ absurd
--   6
--   </pre>
ignored :: IxTraversal i s s a b

-- | Traverse selected elements of a <a>Traversal</a> where their ordinal
--   positions match a predicate.
elementsOf :: Is k A_Traversal => Optic k is s t a a -> (Int -> Bool) -> IxTraversal Int s t a a

-- | Traverse elements of a <a>Traversable</a> container where their
--   ordinal positions match a predicate.
--   
--   <pre>
--   <a>elements</a> ≡ <a>elementsOf</a> <a>traverse</a>
--   </pre>
elements :: Traversable f => (Int -> Bool) -> IxTraversal' Int (f a) a

-- | Traverse the <i>nth</i> element of a <a>Traversal</a> if it exists.
--   
--   TODO: the result ideally should be an indexed affine traversal.
elementOf :: Is k A_Traversal => Optic k is s t a a -> Int -> IxTraversal Int s t a a

-- | Traverse the <i>nth</i> element of a <a>Traversable</a> container.
--   
--   <pre>
--   <a>element</a> ≡ <a>elementOf</a> <a>traversed</a>
--   </pre>
element :: Traversable f => Int -> IxTraversal' Int (f a) a

-- | A version of <a>itraverseOf</a> with the arguments flipped.
iforOf :: (Is k A_Traversal, Applicative f, is `HasSingleIndex` i) => Optic k is s t a b -> s -> (i -> a -> f b) -> f t

-- | Generalizes <a>mapAccumL</a> to an arbitrary <a>IxTraversal</a>.
--   
--   <a>imapAccumLOf</a> accumulates state from left to right.
--   
--   <pre>
--   <a>mapAccumLOf</a> o ≡ <a>imapAccumLOf</a> o <a>.</a> <a>const</a>
--   </pre>
imapAccumLOf :: (Is k A_Traversal, is `HasSingleIndex` i) => Optic k is s t a b -> (i -> acc -> a -> (b, acc)) -> acc -> s -> (t, acc)

-- | Generalizes <a>mapAccumR</a> to an arbitrary <a>IxTraversal</a>.
--   
--   <a>imapAccumROf</a> accumulates state from right to left.
--   
--   <pre>
--   <a>mapAccumROf</a> o ≡ <a>imapAccumROf</a> o <a>.</a> <a>const</a>
--   </pre>
imapAccumROf :: (Is k A_Traversal, is `HasSingleIndex` i) => Optic k is s t a b -> (i -> acc -> a -> (b, acc)) -> acc -> s -> (t, acc)

-- | This permits the use of <a>scanl1</a> over an arbitrary
--   <a>IxTraversal</a>.
iscanl1Of :: (Is k A_Traversal, is `HasSingleIndex` i) => Optic k is s t a a -> (i -> a -> a -> a) -> s -> t

-- | This permits the use of <a>scanr1</a> over an arbitrary
--   <a>IxTraversal</a>.
iscanr1Of :: (Is k A_Traversal, is `HasSingleIndex` i) => Optic k is s t a a -> (i -> a -> a -> a) -> s -> t

-- | Try to map a function which uses the index over this
--   <a>IxTraversal</a>, returning <a>Nothing</a> if the <a>IxTraversal</a>
--   has no targets.
ifailover :: (Is k A_Traversal, is `HasSingleIndex` i) => Optic k is s t a b -> (i -> a -> b) -> s -> Maybe t

-- | Version of <a>ifailover</a> strict in the application of the function.
ifailover' :: (Is k A_Traversal, is `HasSingleIndex` i) => Optic k is s t a b -> (i -> a -> b) -> s -> Maybe t

-- | Filter results of an <a>IxTraversal</a> that don't satisfy a predicate
--   on the indices.
--   
--   <pre>
--   &gt;&gt;&gt; toListOf (itraversed %&amp; indices even) "foobar"
--   "foa"
--   </pre>
indices :: (Is k A_Traversal, is `HasSingleIndex` i) => (i -> Bool) -> Optic k is s t a a -> IxTraversal i s t a a

-- | This allows you to <a>traverse</a> the elements of an indexed
--   traversal in the opposite order.
ibackwards :: (Is k A_Traversal, is `HasSingleIndex` i) => Optic k is s t a b -> IxTraversal i s t a b

-- | An indexed version of <a>partsOf</a> that receives the entire list of
--   indices as its indices.
ipartsOf :: forall k is i s t a. (Is k A_Traversal, is `HasSingleIndex` i) => Optic k is s t a a -> IxLens [i] s t [a] [a]

-- | Tag for a traversal.
data A_Traversal :: OpticKind

-- | Type synonym for a type-modifying van Laarhoven indexed traversal.
type IxTraversalVL i s t a b = forall f. Applicative f => (i -> a -> f b) -> s -> f t

-- | Type synonym for a type-preserving van Laarhoven indexed traversal.
type IxTraversalVL' i s a = IxTraversalVL i s s a a

-- | Class for <a>Traversable</a>s that have an additional read-only index
--   available.
class (FoldableWithIndex i t, Traversable t) => TraversableWithIndex i t | t -> i
itraverse :: (TraversableWithIndex i t, Applicative f) => (i -> a -> f b) -> t a -> f (t b)


-- | This module defines the <a>Each</a> class, which provides an
--   <a>IxTraversal</a> that extracts <a>each</a> element of a (potentially
--   monomorphic) container.
--   
--   Note that orphan instances for this class are defined in the
--   <tt>Optics.Each</tt> module from <tt>optics-extra</tt>, so if you are
--   not simply depending on <tt>optics</tt> you may wish to import that
--   module instead.
module Optics.Each.Core

-- | Extract <a>each</a> element of a (potentially monomorphic) container.
--   
--   <pre>
--   &gt;&gt;&gt; over each (*10) (1,2,3)
--   (10,20,30)
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; iover each (\i a -&gt; a*10 + succ i) (1,2,3)
--   (11,22,33)
--   </pre>
class Each i s t a b | s -> i a, t -> i b, s b -> t, t a -> s
each :: Each i s t a b => IxTraversal i s t a b
each :: (Each i s t a b, TraversableWithIndex i g, s ~ g a, t ~ g b) => IxTraversal i s t a b
instance (a Data.Type.Equality.~ a1, b Data.Type.Equality.~ b1) => Optics.Each.Core.Each GHC.Types.Int (a, a1) (b, b1) a b
instance (a Data.Type.Equality.~ a1, a Data.Type.Equality.~ a2, b Data.Type.Equality.~ b1, b Data.Type.Equality.~ b2) => Optics.Each.Core.Each GHC.Types.Int (a, a1, a2) (b, b1, b2) a b
instance (a Data.Type.Equality.~ a1, a Data.Type.Equality.~ a2, a Data.Type.Equality.~ a3, b Data.Type.Equality.~ b1, b Data.Type.Equality.~ b2, b Data.Type.Equality.~ b3) => Optics.Each.Core.Each GHC.Types.Int (a, a1, a2, a3) (b, b1, b2, b3) a b
instance (a Data.Type.Equality.~ a1, a Data.Type.Equality.~ a2, a Data.Type.Equality.~ a3, a Data.Type.Equality.~ a4, b Data.Type.Equality.~ b1, b Data.Type.Equality.~ b2, b Data.Type.Equality.~ b3, b Data.Type.Equality.~ b4) => Optics.Each.Core.Each GHC.Types.Int (a, a1, a2, a3, a4) (b, b1, b2, b3, b4) a b
instance (a Data.Type.Equality.~ a1, a Data.Type.Equality.~ a2, a Data.Type.Equality.~ a3, a Data.Type.Equality.~ a4, a Data.Type.Equality.~ a5, b Data.Type.Equality.~ b1, b Data.Type.Equality.~ b2, b Data.Type.Equality.~ b3, b Data.Type.Equality.~ b4, b Data.Type.Equality.~ b5) => Optics.Each.Core.Each GHC.Types.Int (a, a1, a2, a3, a4, a5) (b, b1, b2, b3, b4, b5) a b
instance (a Data.Type.Equality.~ a1, a Data.Type.Equality.~ a2, a Data.Type.Equality.~ a3, a Data.Type.Equality.~ a4, a Data.Type.Equality.~ a5, a Data.Type.Equality.~ a6, b Data.Type.Equality.~ b1, b Data.Type.Equality.~ b2, b Data.Type.Equality.~ b3, b Data.Type.Equality.~ b4, b Data.Type.Equality.~ b5, b Data.Type.Equality.~ b6) => Optics.Each.Core.Each GHC.Types.Int (a, a1, a2, a3, a4, a5, a6) (b, b1, b2, b3, b4, b5, b6) a b
instance (a Data.Type.Equality.~ a1, a Data.Type.Equality.~ a2, a Data.Type.Equality.~ a3, a Data.Type.Equality.~ a4, a Data.Type.Equality.~ a5, a Data.Type.Equality.~ a6, a Data.Type.Equality.~ a7, b Data.Type.Equality.~ b1, b Data.Type.Equality.~ b2, b Data.Type.Equality.~ b3, b Data.Type.Equality.~ b4, b Data.Type.Equality.~ b5, b Data.Type.Equality.~ b6, b Data.Type.Equality.~ b7) => Optics.Each.Core.Each GHC.Types.Int (a, a1, a2, a3, a4, a5, a6, a7) (b, b1, b2, b3, b4, b5, b6, b7) a b
instance (a Data.Type.Equality.~ a1, a Data.Type.Equality.~ a2, a Data.Type.Equality.~ a3, a Data.Type.Equality.~ a4, a Data.Type.Equality.~ a5, a Data.Type.Equality.~ a6, a Data.Type.Equality.~ a7, a Data.Type.Equality.~ a8, b Data.Type.Equality.~ b1, b Data.Type.Equality.~ b2, b Data.Type.Equality.~ b3, b Data.Type.Equality.~ b4, b Data.Type.Equality.~ b5, b Data.Type.Equality.~ b6, b Data.Type.Equality.~ b7, b Data.Type.Equality.~ b8) => Optics.Each.Core.Each GHC.Types.Int (a, a1, a2, a3, a4, a5, a6, a7, a8) (b, b1, b2, b3, b4, b5, b6, b7, b8) a b
instance (a Data.Type.Equality.~ a1, a Data.Type.Equality.~ a2, a Data.Type.Equality.~ a3, a Data.Type.Equality.~ a4, a Data.Type.Equality.~ a5, a Data.Type.Equality.~ a6, a Data.Type.Equality.~ a7, a Data.Type.Equality.~ a8, a Data.Type.Equality.~ a9, b Data.Type.Equality.~ b1, b Data.Type.Equality.~ b2, b Data.Type.Equality.~ b3, b Data.Type.Equality.~ b4, b Data.Type.Equality.~ b5, b Data.Type.Equality.~ b6, b Data.Type.Equality.~ b7, b Data.Type.Equality.~ b8, b Data.Type.Equality.~ b9) => Optics.Each.Core.Each GHC.Types.Int (a, a1, a2, a3, a4, a5, a6, a7, a8, a9) (b, b1, b2, b3, b4, b5, b6, b7, b8, b9) a b
instance (a Data.Type.Equality.~ a', b Data.Type.Equality.~ b') => Optics.Each.Core.Each (Data.Either.Either () ()) (Data.Either.Either a a') (Data.Either.Either b b') a b
instance Optics.Each.Core.Each (Data.Either.Either () ()) (Data.Complex.Complex a) (Data.Complex.Complex b) a b
instance (k Data.Type.Equality.~ k') => Optics.Each.Core.Each k (Data.Map.Internal.Map k a) (Data.Map.Internal.Map k' b) a b
instance Optics.Each.Core.Each GHC.Types.Int (Data.IntMap.Internal.IntMap a) (Data.IntMap.Internal.IntMap b) a b
instance Optics.Each.Core.Each GHC.Types.Int [a] [b] a b
instance Optics.Each.Core.Each GHC.Types.Int (GHC.Base.NonEmpty a) (GHC.Base.NonEmpty b) a b
instance Optics.Each.Core.Each () (Data.Functor.Identity.Identity a) (Data.Functor.Identity.Identity b) a b
instance Optics.Each.Core.Each () (GHC.Maybe.Maybe a) (GHC.Maybe.Maybe b) a b
instance Optics.Each.Core.Each GHC.Types.Int (Data.Sequence.Internal.Seq a) (Data.Sequence.Internal.Seq b) a b
instance Optics.Each.Core.Each [GHC.Types.Int] (Data.Tree.Tree a) (Data.Tree.Tree b) a b
instance (GHC.Arr.Ix i, i Data.Type.Equality.~ j) => Optics.Each.Core.Each i (GHC.Arr.Array i a) (GHC.Arr.Array j b) a b


-- | This module defines basic functionality for indexed optics. See the
--   "Indexed optics" section of the overview documentation in the
--   <tt>Optics</tt> module of the main <tt>optics</tt> package for more
--   details.
module Optics.Indexed.Core

-- | Class for optic kinds that can have indices.
class IxOptic k s t a b

-- | Convert an indexed optic to its unindexed equivalent.
noIx :: (IxOptic k s t a b, NonEmptyIndices is) => Optic k is s t a b -> Optic k NoIx s t a b

-- | Construct a conjoined indexed optic that provides a separate code path
--   when used without indices. Useful for defining indexed optics that are
--   as efficient as their unindexed equivalents when used without indices.
--   
--   <i>Note:</i> <tt><a>conjoined</a> f g</tt> is well-defined if and only
--   if <tt>f ≡ <a>noIx</a> g</tt>.
conjoined :: is `HasSingleIndex` i => Optic k NoIx s t a b -> Optic k is s t a b -> Optic k is s t a b

-- | Compose two optics of compatible flavours.
--   
--   Returns an optic of the appropriate supertype. If either or both
--   optics are indexed, the composition preserves all the indices.
(%) :: (Is k m, Is l m, m ~ Join k l, ks ~ Append is js) => Optic k is s t u v -> Optic l js u v a b -> Optic m ks s t a b
infixl 9 %

-- | Compose two indexed optics. Their indices are composed as a pair.
--   
--   <pre>
--   &gt;&gt;&gt; itoListOf (ifolded &lt;%&gt; ifolded) ["foo", "bar"]
--   [((0,0),'f'),((0,1),'o'),((0,2),'o'),((1,0),'b'),((1,1),'a'),((1,2),'r')]
--   </pre>
(<%>) :: (m ~ Join k l, Is k m, Is l m, IxOptic m s t a b, is `HasSingleIndex` i, js `HasSingleIndex` j) => Optic k is s t u v -> Optic l js u v a b -> Optic m (WithIx (i, j)) s t a b
infixl 9 <%>

-- | Compose two indexed optics and drop indices of the left one. (If you
--   want to compose a non-indexed and an indexed optic, you can just use
--   (<a>%</a>).)
--   
--   <pre>
--   &gt;&gt;&gt; itoListOf (ifolded %&gt; ifolded) ["foo", "bar"]
--   [(0,'f'),(1,'o'),(2,'o'),(0,'b'),(1,'a'),(2,'r')]
--   </pre>
(%>) :: (m ~ Join k l, Is k m, Is l m, IxOptic k s t u v, NonEmptyIndices is) => Optic k is s t u v -> Optic l js u v a b -> Optic m js s t a b
infixl 9 %>

-- | Compose two indexed optics and drop indices of the right one. (If you
--   want to compose an indexed and a non-indexed optic, you can just use
--   (<a>%</a>).)
--   
--   <pre>
--   &gt;&gt;&gt; itoListOf (ifolded &lt;% ifolded) ["foo", "bar"]
--   [(0,'f'),(0,'o'),(0,'o'),(1,'b'),(1,'a'),(1,'r')]
--   </pre>
(<%) :: (m ~ Join k l, Is l m, Is k m, IxOptic l u v a b, NonEmptyIndices js) => Optic k is s t u v -> Optic l js u v a b -> Optic m is s t a b
infixl 9 <%

-- | Remap the index.
--   
--   <pre>
--   &gt;&gt;&gt; itoListOf (reindexed succ ifolded) "foo"
--   [(1,'f'),(2,'o'),(3,'o')]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; itoListOf (ifolded %&amp; reindexed succ) "foo"
--   [(1,'f'),(2,'o'),(3,'o')]
--   </pre>
reindexed :: is `HasSingleIndex` i => (i -> j) -> Optic k is s t a b -> Optic k (WithIx j) s t a b

-- | Flatten indices obtained from two indexed optics.
--   
--   <pre>
--   &gt;&gt;&gt; itoListOf (ifolded % ifolded %&amp; icompose (,)) ["foo","bar"]
--   [((0,0),'f'),((0,1),'o'),((0,2),'o'),((1,0),'b'),((1,1),'a'),((1,2),'r')]
--   </pre>
icompose :: (i -> j -> ix) -> Optic k '[i, j] s t a b -> Optic k (WithIx ix) s t a b

-- | Flatten indices obtained from three indexed optics.
--   
--   <pre>
--   &gt;&gt;&gt; itoListOf (ifolded % ifolded % ifolded %&amp; icompose3 (,,)) [["foo","bar"],["xyz"]]
--   [((0,0,0),'f'),((0,0,1),'o'),((0,0,2),'o'),((0,1,0),'b'),((0,1,1),'a'),((0,1,2),'r'),((1,0,0),'x'),((1,0,1),'y'),((1,0,2),'z')]
--   </pre>
icompose3 :: (i1 -> i2 -> i3 -> ix) -> Optic k '[i1, i2, i3] s t a b -> Optic k (WithIx ix) s t a b

-- | Flatten indices obtained from four indexed optics.
icompose4 :: (i1 -> i2 -> i3 -> i4 -> ix) -> Optic k '[i1, i2, i3, i4] s t a b -> Optic k (WithIx ix) s t a b

-- | Flatten indices obtained from five indexed optics.
icompose5 :: (i1 -> i2 -> i3 -> i4 -> i5 -> ix) -> Optic k '[i1, i2, i3, i4, i5] s t a b -> Optic k (WithIx ix) s t a b

-- | Flatten indices obtained from arbitrary number of indexed optics.
icomposeN :: forall k i is s t a b. (CurryCompose is, NonEmptyIndices is) => Curry is i -> Optic k is s t a b -> Optic k (WithIx i) s t a b

-- | Class for <a>Functor</a>s that have an additional read-only index
--   available.
class Functor f => FunctorWithIndex i f | f -> i
imap :: FunctorWithIndex i f => (i -> a -> b) -> f a -> f b
imap :: (FunctorWithIndex i f, TraversableWithIndex i f) => (i -> a -> b) -> f a -> f b

-- | Class for <a>Foldable</a>s that have an additional read-only index
--   available.
class (FunctorWithIndex i f, Foldable f) => FoldableWithIndex i f | f -> i
ifoldMap :: (FoldableWithIndex i f, Monoid m) => (i -> a -> m) -> f a -> m
ifoldMap :: (FoldableWithIndex i f, TraversableWithIndex i f, Monoid m) => (i -> a -> m) -> f a -> m
ifoldr :: FoldableWithIndex i f => (i -> a -> b -> b) -> b -> f a -> b
ifoldl' :: FoldableWithIndex i f => (i -> b -> a -> b) -> b -> f a -> b

-- | Traverse <a>FoldableWithIndex</a> ignoring the results.
itraverse_ :: (FoldableWithIndex i t, Applicative f) => (i -> a -> f b) -> t a -> f ()

-- | Flipped <a>itraverse_</a>.
ifor_ :: (FoldableWithIndex i t, Applicative f) => t a -> (i -> a -> f b) -> f ()

-- | Class for <a>Traversable</a>s that have an additional read-only index
--   available.
class (FoldableWithIndex i t, Traversable t) => TraversableWithIndex i t | t -> i
itraverse :: (TraversableWithIndex i t, Applicative f) => (i -> a -> f b) -> t a -> f (t b)

-- | Flipped <a>itraverse</a>
ifor :: (TraversableWithIndex i t, Applicative f) => t a -> (i -> a -> f b) -> f (t b)
instance (s Data.Type.Equality.~ t, a Data.Type.Equality.~ b) => Optics.Indexed.Core.IxOptic Optics.Internal.Optic.Types.A_Getter s t a b
instance Optics.Indexed.Core.IxOptic Optics.Internal.Optic.Types.A_Lens s t a b
instance Optics.Indexed.Core.IxOptic Optics.Internal.Optic.Types.An_AffineTraversal s t a b
instance (s Data.Type.Equality.~ t, a Data.Type.Equality.~ b) => Optics.Indexed.Core.IxOptic Optics.Internal.Optic.Types.An_AffineFold s t a b
instance Optics.Indexed.Core.IxOptic Optics.Internal.Optic.Types.A_Traversal s t a b
instance (s Data.Type.Equality.~ t, a Data.Type.Equality.~ b) => Optics.Indexed.Core.IxOptic Optics.Internal.Optic.Types.A_Fold s t a b
instance Optics.Indexed.Core.IxOptic Optics.Internal.Optic.Types.A_Setter s t a b


-- | See the <tt>Optics</tt> module in the main <tt>optics</tt> package for
--   overview documentation.
module Optics.Core


-- | This module defines optics for constructing and manipulating finite
--   <a>Seq</a>s.
module Data.Sequence.Optics

-- | A <a>Seq</a> is isomorphic to a <a>ViewL</a>
--   
--   <pre>
--   <a>viewl</a> m ≡ m <a>^.</a> <a>viewL</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [1,2,3] ^. viewL
--   1 :&lt; fromList [2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.empty ^. viewL
--   EmptyL
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; EmptyL ^. re viewL
--   fromList []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; review viewL $ 1 Seq.:&lt; fromList [2,3]
--   fromList [1,2,3]
--   </pre>
viewL :: Iso (Seq a) (Seq b) (ViewL a) (ViewL b)

-- | A <a>Seq</a> is isomorphic to a <a>ViewR</a>
--   
--   <pre>
--   <a>viewr</a> m ≡ m <a>^.</a> <a>viewR</a>
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.fromList [1,2,3] ^. viewR
--   fromList [1,2] :&gt; 3
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; Seq.empty ^. viewR
--   EmptyR
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; EmptyR ^. re viewR
--   fromList []
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; review viewR $ fromList [1,2] Seq.:&gt; 3
--   fromList [1,2,3]
--   </pre>
viewR :: Iso (Seq a) (Seq b) (ViewR a) (ViewR b)

-- | Traverse all the elements numbered from <tt>i</tt> to <tt>j</tt> of a
--   <a>Seq</a>
--   
--   <pre>
--   &gt;&gt;&gt; fromList [1,2,3,4,5] &amp; sliced 1 3 %~ (*10)
--   fromList [1,20,30,4,5]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromList [1,2,3,4,5] ^.. sliced 1 3
--   [2,3]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromList [1,2,3,4,5] &amp; sliced 1 3 .~ 0
--   fromList [1,0,0,4,5]
--   </pre>
sliced :: Int -> Int -> IxTraversal' Int (Seq a) a

-- | Traverse the first <tt>n</tt> elements of a <a>Seq</a>
--   
--   <pre>
--   &gt;&gt;&gt; fromList [1,2,3,4,5] ^.. slicedTo 2
--   [1,2]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromList [1,2,3,4,5] &amp; slicedTo 2 %~ (*10)
--   fromList [10,20,3,4,5]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromList [1,2,4,5,6] &amp; slicedTo 10 .~ 0
--   fromList [0,0,0,0,0]
--   </pre>
slicedTo :: Int -> IxTraversal' Int (Seq a) a

-- | Traverse all but the first <tt>n</tt> elements of a <a>Seq</a>
--   
--   <pre>
--   &gt;&gt;&gt; fromList [1,2,3,4,5] ^.. slicedFrom 2
--   [3,4,5]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromList [1,2,3,4,5] &amp; slicedFrom 2 %~ (*10)
--   fromList [1,2,30,40,50]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; fromList [1,2,3,4,5] &amp; slicedFrom 10 .~ 0
--   fromList [1,2,3,4,5]
--   </pre>
slicedFrom :: Int -> IxTraversal' Int (Seq a) a

-- | Construct a <a>Seq</a> from a fold.
--   
--   <pre>
--   &gt;&gt;&gt; seqOf folded ["hello","world"]
--   fromList ["hello","world"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; seqOf (folded % _2) [("hello",1),("world",2),("!!!",3)]
--   fromList [1,2,3]
--   </pre>
seqOf :: Is k A_Fold => Optic' k is s a -> s -> Seq a
